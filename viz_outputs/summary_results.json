[
  {
    "ok": true,
    "topic": "explain me projectile motion using cricket",
    "slide_id": 5,
    "slide_name": "Effect of Launch Angle and Initial Velocity",
    "workdir": "/home/dikshant-kukreja/Desktop/extramarks/viz_outputs/explain_me_projectile_motion_using_cricket/05_Effect_of_Launch_Angle_and_Initial_Velocity",
    "language": "python",
    "filename": "cricket_projectile_angle_velocity.py",
    "run_exit_code": 0,
    "stdout": "Saved figure: cricket_projectile_angle_velocity.png\n",
    "stderr": "",
    "saved_artifacts": [
      "cricket_projectile_angle_velocity.png"
    ],
    "model_json": {
      "language": "python",
      "filename": "cricket_projectile_angle_velocity.py",
      "code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n# Parameters\ng = 9.81  # m/s^2\nboundary_distance = 70  # meters (typical boundary distance for a six)\n\n\ndef trajectory(v0, angle_deg, g=9.81, num=300):\n    theta = np.radians(angle_deg)\n    t_flight = 2 * v0 * np.sin(theta) / g\n    t = np.linspace(0, t_flight, num)\n    x = v0 * np.cos(theta) * t\n    y = v0 * np.sin(theta) * t - 0.5 * g * t**2\n    return x, y\n\n\n# Figure setup\nplt.figure(figsize=(12, 5.5))\n\n# Left subplot: Vary launch angle at fixed speed\nax1 = plt.subplot(1, 2, 1)\nv0_fixed = 35  # m/s\nangles = [25, 35, 45, 55]\ncolors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\"]\nmax_x1 = 0\nmax_y1 = 0\nfor ang, c in zip(angles, colors):\n    x, y = trajectory(v0_fixed, ang, g)\n    ax1.plot(x, y, label=f\"{ang}°\", color=c, lw=2)\n    ax1.plot(x[-1], y[-1], marker='o', color=c, ms=5)\n    max_x1 = max(max_x1, x[-1])\n    max_y1 = max(max_y1, y.max())\n\n# Boundary marker\nax1.axvline(boundary_distance, color='gray', ls='--', lw=1.5)\nax1.text(boundary_distance, max_y1 * 0.05 + 0.5, \"Boundary ~70 m (Six)\", rotation=90,\n         va='bottom', ha='center', color='gray')\n\n# Ground line\nax1.axhline(0, color='k', lw=1)\n\n# Annotation for 45° maximum range (on level ground, no air resistance)\nx45, y45 = trajectory(v0_fixed, 45, g)\ni_apex = np.argmax(y45)\nax1.annotate(\"45° gives maximum range\\n(on level ground, no air resistance)\",\n             xy=(x45[i_apex], y45[i_apex]), xytext=(x45[i_apex] * 0.55, y45[i_apex] * 1.25),\n             arrowprops=dict(arrowstyle='->', color='#2ca02c'),\n             fontsize=9, color='#2ca02c', ha='center')\n\nax1.set_title(f\"Effect of launch angle (speed = {v0_fixed} m/s)\")\nax1.set_xlabel(\"Horizontal distance (m)\")\nax1.set_ylabel(\"Height (m)\")\nax1.grid(True, ls=':', alpha=0.6)\nax1.legend(title=\"Angle\", frameon=False)\nax1.set_xlim(0, max_x1 * 1.1)\nax1.set_ylim(0, max_y1 * 1.2)\n\n# Right subplot: Vary initial speed at fixed angle\nax2 = plt.subplot(1, 2, 2)\nangle_fixed = 35  # degrees\nspeeds = [25, 30, 35, 40]  # m/s\ncolors2 = [\"#9467bd\", \"#8c564b\", \"#17becf\", \"#e377c2\"]\nmax_x2 = 0\nmax_y2 = 0\nfor v, c in zip(speeds, colors2):\n    x, y = trajectory(v, angle_fixed, g)\n    ax2.plot(x, y, label=f\"{v} m/s\", color=c, lw=2)\n    ax2.plot(x[-1], y[-1], marker='o', color=c, ms=5)\n    max_x2 = max(max_x2, x[-1])\n    max_y2 = max(max_y2, y.max())\n\n# Boundary marker\nax2.axvline(boundary_distance, color='gray', ls='--', lw=1.5)\nax2.text(boundary_distance, max_y2 * 0.05 + 0.5, \"Boundary ~70 m (Six)\", rotation=90,\n         va='bottom', ha='center', color='gray')\n\n# Ground line\nax2.axhline(0, color='k', lw=1)\n\nax2.set_title(f\"Effect of initial speed (angle = {angle_fixed}°)\")\nax2.set_xlabel(\"Horizontal distance (m)\")\nax2.set_ylabel(\"Height (m)\")\nax2.grid(True, ls=':', alpha=0.6)\nax2.legend(title=\"Speed\", frameon=False)\nax2.set_xlim(0, max_x2 * 1.1)\nax2.set_ylim(0, max_y2 * 1.2)\n\n# Suptitle and note\nplt.suptitle(\"Cricket ball projectile motion: launch angle and initial speed\", y=1.02, fontsize=13)\nplt.figtext(0.5, -0.02,\n            \"Assumptions: level ground, no air resistance. Higher speed and an optimal angle increase both height and range.\",\n            ha='center', fontsize=9, color='dimgray')\n\nplt.tight_layout()\nplt.savefig(\"cricket_projectile_angle_velocity.png\", dpi=200, bbox_inches='tight')\nprint(\"Saved figure: cricket_projectile_angle_velocity.png\")\n",
      "run_instructions": "Run: python cricket_projectile_angle_velocity.py\nThis will save 'cricket_projectile_angle_velocity.png' in the working directory.",
      "python_packages": [
        "matplotlib",
        "numpy"
      ],
      "r_packages": [],
      "latex_requires": []
    }
  },
  {
    "ok": false,
    "topic": "explain me projectile motion using cricket",
    "slide_id": 7,
    "slide_name": "Trajectory and Path Characteristics",
    "workdir": "/home/dikshant-kukreja/Desktop/extramarks/viz_outputs/explain_me_projectile_motion_using_cricket/07_Trajectory_and_Path_Characteristics",
    "language": "python",
    "filename": "cricket_projectile_trajectory.py",
    "run_exit_code": 1,
    "stdout": "",
    "stderr": "  File \u001b[35m\"/home/dikshant-kukreja/Desktop/extramarks/viz_outputs/explain_me_projectile_motion_using_cricket/07_Trajectory_and_Path_Characteristics/cricket_projectile_trajectory.py\"\u001b[0m, line \u001b[35m36\u001b[0m\n    ax.plot(x, y, color=colors[ang], lw=lw, label=f\"Launch angle \u0003b8 = {ang}\n\u001b[1;35mSyntaxError\u001b[0m: \u001b[35msource code cannot contain null bytes\u001b[0m\n",
    "saved_artifacts": [],
    "model_json": {
      "language": "python",
      "filename": "cricket_projectile_trajectory.py",
      "code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef trajectory_data(v0, angle_deg, y0=1.0, g=9.81, n=600):\n    theta = np.deg2rad(angle_deg)\n    vy0 = v0 * np.sin(theta)\n    vx0 = v0 * np.cos(theta)\n    # Time of flight to y=0 (ground): y0 + vy0 t - 1/2 g t^2 = 0\n    t_flight = (vy0 + np.sqrt(vy0**2 + 2 * g * y0)) / g\n    t = np.linspace(0, t_flight, n)\n    x = vx0 * t\n    y = y0 + vy0 * t - 0.5 * g * t**2\n    return x, y, t_flight, vx0, vy0\n\n\ndef main():\n    # Parameters (reasonable for a high cricket lofted shot / throw)\n    v0 = 30.0  # m/s\n    y0 = 1.0   # m launch height (approx. ball release height)\n    g = 9.81   # m/s^2\n\n    angles = [35, 45, 55]\n    colors = {35: '#1f77b4', 45: '#2ca02c', 55: '#d62728'}\n\n    fig, ax = plt.subplots(figsize=(10.5, 6.5))\n\n    ranges = []\n    ymaxs = []\n\n    # Plot trajectories\n    for ang in angles:\n        x, y, t_f, vx0, vy0 = trajectory_data(v0, ang, y0=y0, g=g)\n        lw = 3 if ang == 45 else 2\n        z = 4 if ang == 45 else 3\n        ax.plot(x, y, color=colors[ang], lw=lw, label=f\"Launch angle \u0003b8 = {ang}\u0000b0\", zorder=z)\n        # Collect range and max height\n        x_range = vx0 * t_f\n        ranges.append(x_range)\n        ymaxs.append(y.max())\n\n        if ang == 45:\n            # Apex for highlighting symmetry\n            t_peak = vy0 / g\n            t_peak = max(0, min(t_peak, t_f))\n            x_peak = vx0 * t_peak\n            y_peak = y0 + vy0 * t_peak - 0.5 * g * t_peak**2\n            ax.plot([x_peak], [y_peak], marker='o', color=colors[ang], ms=7, zorder=6)\n            ax.vlines(x_peak, 0, y_peak, colors=colors[ang], linestyles='--', lw=1.8, zorder=2)\n            ax.text(x_peak, y_peak + 0.8, 'Apex (maximum height)', color=colors[ang], ha='center', va='bottom')\n            ax.text(x_peak, y_peak * 0.45, 'symmetric about apex\\n(ignoring air resistance)',\n                    color=colors[ang], ha='center', va='center', fontsize=10)\n            # Mark landing point (probable fielder position)\n            ax.plot([x_range], [0], marker='o', color='k', ms=6, zorder=7)\n            ax.annotate('probable landing zone /\\nfielder position',\n                        xy=(x_range, 0), xytext=(x_range * 0.8, max(2.0, y_peak * 0.25)),\n                        arrowprops=dict(arrowstyle='->', color='k', lw=1.6),\n                        ha='right', va='bottom', fontsize=10)\n\n    # Axes limits\n    x_max = max(ranges) * 1.08\n    y_max = max(ymaxs) * 1.22\n\n    # Ground line\n    ax.axhline(0, color='#666666', lw=2)\n\n    # Range double-arrow for the 45\u0000b0 case\n    # Recompute to get exact range value for annotation\n    x45, y45, t45, vx45, vy45 = trajectory_data(v0, 45, y0=y0, g=g)\n    r45 = vx45 * t45\n    y_arrow = max(0.04 * y_max, 0.5)\n    ax.annotate('', xy=(0, y_arrow), xytext=(r45, y_arrow),\n                arrowprops=dict(arrowstyle='<->', color='#2ca02c', lw=2))\n    ax.text(r45 * 0.5, y_arrow + 0.35, f'Range \b8\b9 R \b8\b9 \u00067 {r45:.1f} m',\n            color='#2ca02c', ha='center', va='bottom')\n\n    # Labels, title, legend\n    ax.set_xlim(0, x_max)\n    ax.set_ylim(0, y_max)\n    ax.set_xlabel('Horizontal distance (m)')\n    ax.set_ylabel('Height (m)')\n    ax.set_title('Projectile Motion in Cricket: Parabolic Trajectory (ignoring air resistance)')\n\n    # Helpful equations box\n    eq_text = (r'Projectile equations (no air drag):' '\\n'\n               r'$x(t) = v_0\\cos\\theta\\;t$' '\\n'\n               r'$y(t) = y_0 + v_0\\sin\\theta\\;t - \\tfrac{1}{2}gt^2$' '\\n'\n               r'Maximum range on level ground at $\\theta \\approx 45^\\circ$')\n    ax.text(0.02 * x_max, 0.88 * y_max, eq_text,\n            fontsize=10.5, va='top', ha='left',\n            bbox=dict(boxstyle='round,pad=0.35', facecolor='white', alpha=0.9, ec='#333333'))\n\n    # Grid and legend\n    ax.grid(True, which='both', ls='--', lw=0.6, alpha=0.5)\n    leg = ax.legend(frameon=True)\n    leg.get_frame().set_alpha(0.9)\n\n    plt.tight_layout()\n    out_name = 'cricket_projectile_trajectory.png'\n    plt.savefig(out_name, dpi=200, bbox_inches='tight')\n    print(f'Saved figure to {out_name}')\n\n\nif __name__ == '__main__':\n    main()\n",
      "run_instructions": "Run: python cricket_projectile_trajectory.py. The script will save 'cricket_projectile_trajectory.png' in the working directory.",
      "python_packages": [
        "numpy",
        "matplotlib"
      ],
      "r_packages": [],
      "latex_requires": []
    }
  },
  {
    "ok": false,
    "topic": "explain me projectile motion using cricket",
    "slide_id": 4,
    "slide_name": "Kinematic Equations for Projectile Motion",
    "workdir": "/home/dikshant-kukreja/Desktop/extramarks/viz_outputs/explain_me_projectile_motion_using_cricket/04_Kinematic_Equations_for_Projectile_Motion",
    "language": "python",
    "filename": "cricket_projectile_kinematics.py",
    "run_exit_code": 1,
    "stdout": "",
    "stderr": "Traceback (most recent call last):\n  File \u001b[35m\"/home/dikshant-kukreja/Desktop/extramarks/viz_outputs/explain_me_projectile_motion_using_cricket/04_Kinematic_Equations_for_Projectile_Motion/cricket_projectile_kinematics.py\"\u001b[0m, line \u001b[35m126\u001b[0m, in \u001b[35m<module>\u001b[0m\n    \u001b[31mmain\u001b[0m\u001b[1;31m()\u001b[0m\n    \u001b[31m~~~~\u001b[0m\u001b[1;31m^^\u001b[0m\n  File \u001b[35m\"/home/dikshant-kukreja/Desktop/extramarks/viz_outputs/explain_me_projectile_motion_using_cricket/04_Kinematic_Equations_for_Projectile_Motion/cricket_projectile_kinematics.py\"\u001b[0m, line \u001b[35m119\u001b[0m, in \u001b[35mmain\u001b[0m\n    \u001b[31mplt.tight_layout\u001b[0m\u001b[1;31m()\u001b[0m\n    \u001b[31m~~~~~~~~~~~~~~~~\u001b[0m\u001b[1;31m^^\u001b[0m\n  File \u001b[35m\"/home/dikshant-kukreja/miniconda3/lib/python3.13/site-packages/matplotlib/pyplot.py\"\u001b[0m, line \u001b[35m2844\u001b[0m, in \u001b[35mtight_layout\u001b[0m\n    \u001b[31mgcf().tight_layout\u001b[0m\u001b[1;31m(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)\u001b[0m\n    \u001b[31m~~~~~~~~~~~~~~~~~~\u001b[0m\u001b[1;31m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n  File \u001b[35m\"/home/dikshant-kukreja/miniconda3/lib/python3.13/site-packages/matplotlib/figure.py\"\u001b[0m, line \u001b[35m3640\u001b[0m, in \u001b[35mtight_layout\u001b[0m\n    \u001b[31mengine.execute\u001b[0m\u001b[1;31m(self)\u001b[0m\n    \u001b[31m~~~~~~~~~~~~~~\u001b[0m\u001b[1;31m^^^^^^\u001b[0m\n  File \u001b[35m\"/home/dikshant-kukreja/miniconda3/lib/python3.13/site-packages/matplotlib/layout_engine.py\"\u001b[0m, line \u001b[35m188\u001b[0m, in \u001b[35mexecute\u001b[0m\n    kwargs = get_tight_layout_figure(\n        fig, fig.axes, get_subplotspec_list(fig.axes), renderer,\n        pad=info['pad'], h_pad=info['h_pad'], w_pad=info['w_pad'],\n        rect=info['rect'])\n  File \u001b[35m\"/home/dikshant-kukreja/miniconda3/lib/python3.13/site-packages/matplotlib/_tight_layout.py\"\u001b[0m, line \u001b[35m266\u001b[0m, in \u001b[35mget_tight_layout_figure\u001b[0m\n    kwargs = _auto_adjust_subplotpars(fig, renderer,\n                                      shape=(max_nrows, max_ncols),\n    ...<2 lines>...\n                                      ax_bbox_list=ax_bbox_list,\n                                      pad=pad, h_pad=h_pad, w_pad=w_pad)\n  File \u001b[35m\"/home/dikshant-kukreja/miniconda3/lib/python3.13/site-packages/matplotlib/_tight_layout.py\"\u001b[0m, line \u001b[35m82\u001b[0m, in \u001b[35m_auto_adjust_subplotpars\u001b[0m\n    bb += [\u001b[31mmartist._get_tightbbox_for_layout_only\u001b[0m\u001b[1;31m(ax, renderer)\u001b[0m]\n           \u001b[31m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\u001b[1;31m^^^^^^^^^^^^^^\u001b[0m\n  File \u001b[35m\"/home/dikshant-kukreja/miniconda3/lib/python3.13/site-packages/matplotlib/artist.py\"\u001b[0m, line \u001b[35m1402\u001b[0m, in \u001b[35m_get_tightbbox_for_layout_only\u001b[0m\n    return \u001b[31mobj.get_tightbbox\u001b[0m\u001b[1;31m(*args, **{**kwargs, \"for_layout_only\": True})\u001b[0m\n           \u001b[31m~~~~~~~~~~~~~~~~~\u001b[0m\u001b[1;31m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n  File \u001b[35m\"/home/dikshant-kukreja/miniconda3/lib/python3.13/site-packages/matplotlib/axes/_base.py\"\u001b[0m, line \u001b[35m4587\u001b[0m, in \u001b[35mget_tightbbox\u001b[0m\n    bbox = a.get_tightbbox(renderer)\n  File \u001b[35m\"/home/dikshant-kukreja/miniconda3/lib/python3.13/site-packages/matplotlib/artist.py\"\u001b[0m, line \u001b[35m364\u001b[0m, in \u001b[35mget_tightbbox\u001b[0m\n    bbox = self.get_window_extent(renderer)\n  File \u001b[35m\"/home/dikshant-kukreja/miniconda3/lib/python3.13/site-packages/matplotlib/text.py\"\u001b[0m, line \u001b[35m969\u001b[0m, in \u001b[35mget_window_extent\u001b[0m\n    bbox, info, descent = \u001b[31mself._get_layout\u001b[0m\u001b[1;31m(self._renderer)\u001b[0m\n                          \u001b[31m~~~~~~~~~~~~~~~~\u001b[0m\u001b[1;31m^^^^^^^^^^^^^^^^\u001b[0m\n  File \u001b[35m\"/home/dikshant-kukreja/miniconda3/lib/python3.13/site-packages/matplotlib/text.py\"\u001b[0m, line \u001b[35m382\u001b[0m, in \u001b[35m_get_layout\u001b[0m\n    w, h, d = \u001b[31m_get_text_metrics_with_cache\u001b[0m\u001b[1;31m(\u001b[0m\n              \u001b[31m~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\u001b[1;31m^\u001b[0m\n        \u001b[1;31mrenderer, clean_line, self._fontproperties,\u001b[0m\n        \u001b[1;31m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n        \u001b[1;31mismath=ismath, dpi=self.get_figure(root=True).dpi)\u001b[0m\n        \u001b[1;31m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n  File \u001b[35m\"/home/dikshant-kukreja/miniconda3/lib/python3.13/site-packages/matplotlib/text.py\"\u001b[0m, line \u001b[35m69\u001b[0m, in \u001b[35m_get_text_metrics_with_cache\u001b[0m\n    return _get_text_metrics_with_cache_impl(\n        weakref.ref(renderer), text, fontprop.copy(), ismath, dpi)\n  File \u001b[35m\"/home/dikshant-kukreja/miniconda3/lib/python3.13/site-packages/matplotlib/text.py\"\u001b[0m, line \u001b[35m77\u001b[0m, in \u001b[35m_get_text_metrics_with_cache_impl\u001b[0m\n    return \u001b[31mrenderer_ref().get_text_width_height_descent\u001b[0m\u001b[1;31m(text, fontprop, ismath)\u001b[0m\n           \u001b[31m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\u001b[1;31m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n  File \u001b[35m\"/home/dikshant-kukreja/miniconda3/lib/python3.13/site-packages/matplotlib/backends/backend_agg.py\"\u001b[0m, line \u001b[35m215\u001b[0m, in \u001b[35mget_text_width_height_descent\u001b[0m\n    \u001b[31mself.mathtext_parser.parse\u001b[0m\u001b[1;31m(s, self.dpi, prop)\u001b[0m\n    \u001b[31m~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\u001b[1;31m^^^^^^^^^^^^^^^^^^^\u001b[0m\n  File \u001b[35m\"/home/dikshant-kukreja/miniconda3/lib/python3.13/site-packages/matplotlib/mathtext.py\"\u001b[0m, line \u001b[35m86\u001b[0m, in \u001b[35mparse\u001b[0m\n    return \u001b[31mself._parse_cached\u001b[0m\u001b[1;31m(s, dpi, prop, antialiased, load_glyph_flags)\u001b[0m\n           \u001b[31m~~~~~~~~~~~~~~~~~~\u001b[0m\u001b[1;31m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n  File \u001b[35m\"/home/dikshant-kukreja/miniconda3/lib/python3.13/site-packages/matplotlib/mathtext.py\"\u001b[0m, line \u001b[35m100\u001b[0m, in \u001b[35m_parse_cached\u001b[0m\n    box = self._parser.parse(s, fontset, fontsize, dpi)\n  File \u001b[35m\"/home/dikshant-kukreja/miniconda3/lib/python3.13/site-packages/matplotlib/_mathtext.py\"\u001b[0m, line \u001b[35m2173\u001b[0m, in \u001b[35mparse\u001b[0m\n    raise ValueError(\"\\n\" + ParseException.explain(err, 0)) from None\n\u001b[1;35mValueError\u001b[0m: \u001b[35m\nv_\\!0\\cos\\theta\n  ^\nParseSyntaxException: Expected {accent | symbol | function | operatorname | group | frac | dfrac | binom | genfrac | overset | underset | sqrt | overline | text | boldsymbol | substack}, found '\\'  (at char 2), (line:1, col:3)\u001b[0m\n",
    "saved_artifacts": [],
    "model_json": {
      "language": "python",
      "filename": "cricket_projectile_kinematics.py",
      "code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef projectile_points(v0, theta_rad, g=9.81, num=300):\n    t_flight = 2 * v0 * np.sin(theta_rad) / g\n    t = np.linspace(0, t_flight, num)\n    x = v0 * np.cos(theta_rad) * t\n    y = v0 * np.sin(theta_rad) * t - 0.5 * g * t**2\n    return t, x, y, t_flight\n\n\ndef main():\n    # Parameters (feel free to tweak for different shots)\n    g = 9.81  # m/s^2\n    v0 = 35.0  # initial speed (m/s)\n    theta_deg = 50.0  # launch angle (degrees)\n    theta = np.deg2rad(theta_deg)\n\n    # Trajectory and key quantities\n    t, x, y, t_flight = projectile_points(v0, theta, g=g, num=600)\n    t_apex = v0 * np.sin(theta) / g\n    H_max = (v0**2) * (np.sin(theta)**2) / (2 * g)\n    R = (v0**2) * np.sin(2 * theta) / g\n    x_apex = v0 * np.cos(theta) * t_apex\n\n    # Sample positions to show time dependence (exclude endpoints)\n    n_samples = 4\n    t_samples = np.linspace(0, t_flight, n_samples + 2)[1:-1]\n    x_s = v0 * np.cos(theta) * t_samples\n    y_s = v0 * np.sin(theta) * t_samples - 0.5 * g * t_samples**2\n\n    # Figure setup\n    plt.rcParams.update({\n        \"font.size\": 11,\n        \"axes.grid\": True,\n        \"grid.color\": \"#e6e6e6\",\n        \"grid.linestyle\": \"-\",\n        \"grid.linewidth\": 0.8,\n    })\n\n    fig, ax = plt.subplots(figsize=(10, 6))\n\n    # Ground line\n    ax.axhline(0, color=\"0.2\", lw=1)\n\n    # Trajectory\n    ax.plot(x, y, color=\"forestgreen\", lw=2.5, label=\"Ball path\")\n\n    # Sampled positions\n    ax.scatter(x_s, y_s, s=50, color=\"crimson\", edgecolor=\"white\", zorder=5, label=\"Sampled positions\")\n    for ti, xi, yi in zip(t_samples, x_s, y_s):\n        dy = 0.04 * max(H_max, 1.0)\n        va = \"bottom\" if ti <= t_apex else \"top\"\n        ax.text(xi, yi + (dy if va == \"bottom\" else -dy), f\"t = {ti:.1f} s\", ha=\"center\", va=va,\n                bbox=dict(facecolor=\"white\", alpha=0.85, boxstyle=\"round,pad=0.2\"), fontsize=9)\n\n    # Velocity decomposition arrows at launch\n    # Scales chosen for clarity (do not reflect exact magnitudes)\n    len_scale = 0.18 * R\n    # v0 arrow\n    ax.annotate(\"\", xy=(len_scale * np.cos(theta), len_scale * np.sin(theta)), xytext=(0, 0),\n                arrowprops=dict(arrowstyle=\"->\", lw=2.2, color=\"tab:blue\"))\n    ax.text(len_scale * np.cos(theta) * 1.05, len_scale * np.sin(theta) * 1.05,\n            r\"$v_0$\", color=\"tab:blue\", ha=\"left\", va=\"bottom\")\n    # v0*cos(theta) arrow (horizontal)\n    ax.annotate(\"\", xy=(0.22 * R, 0), xytext=(0, 0),\n                arrowprops=dict(arrowstyle=\"->\", lw=2, color=\"tab:orange\"))\n    ax.text(0.11 * R, 0.06 * max(H_max, 1.0), r\"$v_\\!0\\cos\\theta$\", color=\"tab:orange\", ha=\"center\")\n    # v0*sin(theta) arrow (vertical)\n    ax.annotate(\"\", xy=(0, 0.5 * H_max if H_max > 0 else 5.0), xytext=(0, 0),\n                arrowprops=dict(arrowstyle=\"->\", lw=2, color=\"tab:purple\"))\n    ax.text(0.02 * R, 0.25 * (H_max if H_max > 0 else 5.0), r\"$v_\\!0\\sin\\theta$\", color=\"tab:purple\",\n            rotation=90, va=\"center\")\n\n    # Gravity indication near apex\n    ax.annotate(\"\", xy=(x_apex, H_max - 0.35 * H_max), xytext=(x_apex, H_max + 0.15 * H_max),\n                arrowprops=dict(arrowstyle=\"->\", lw=1.6, color=\"black\"))\n    ax.text(x_apex + 0.01 * R, H_max, r\"$g$ downward\", va=\"center\", ha=\"left\")\n\n    # Show H_max and Range R with dashed helpers\n    ax.hlines(H_max, 0, x_apex, colors=\"gray\", linestyles=\"--\", linewidth=1)\n    ax.text(0.01 * R, H_max + 0.02 * H_max, r\"$H_{\\max}$\", ha=\"left\", va=\"bottom\")\n    ax.vlines(R, 0, 0.12 * max(H_max, 1.0), colors=\"gray\", linestyles=\"--\", linewidth=1)\n    ax.text(R, 0.14 * max(H_max, 1.0), r\"$R$\", ha=\"center\", va=\"bottom\")\n\n    # Explanatory text boxes\n    eq_text = (r\"Kinematic equations (cricket ball):\\n\"\n               r\"$x(t) = v_0\\cos\\theta\\, t$\\n\"\n               r\"$y(t) = v_0\\sin\\theta\\, t - \\tfrac{1}{2} g t^2$\\n\"\n               r\"$v_x(t) = v_0\\cos\\theta$ (constant)\\n\"\n               r\"$v_y(t) = v_0\\sin\\theta - g t$\")\n    ax.text(0.02, 0.98, eq_text, transform=ax.transAxes, ha=\"left\", va=\"top\",\n            bbox=dict(boxstyle=\"round\", facecolor=\"white\", alpha=0.95), fontsize=10)\n\n    summary_text = (f\"Given: v0 = {v0:.0f} m/s, \"\n                    + r\"$\\theta$\" + f\" = {theta_deg:.0f}°\\n\"\n                    + f\"Time of flight ≈ {t_flight:.2f} s\\n\"\n                    + f\"Range R ≈ {R:.1f} m\\n\"\n                    + f\"Max height H ≈ {H_max:.1f} m\")\n    ax.text(0.98, 0.98, summary_text, transform=ax.transAxes, ha=\"right\", va=\"top\",\n            bbox=dict(boxstyle=\"round\", facecolor=\"white\", alpha=0.95), fontsize=10)\n\n    # Additional hints\n    ax.text(0.60 * R, 0.08 * max(H_max, 1.0), \"Horizontal motion:\\nconstant speed\",\n            bbox=dict(boxstyle=\"round\", facecolor=\"white\", alpha=0.9))\n\n    # Labels and limits\n    ax.set_title(\"Kinematic Equations for a Lofted Cricket Shot\")\n    ax.set_xlabel(\"Horizontal distance x (m)\")\n    ax.set_ylabel(\"Vertical height y (m)\")\n\n    ax.set_xlim(-0.02 * R, 1.05 * R)\n    ax.set_ylim(-0.02 * max(H_max, 1.0), 1.25 * max(H_max, 1.0))\n\n    ax.legend(loc=\"lower right\", frameon=True)\n\n    out_name = \"projectile_motion_cricket_kinematics.png\"\n    plt.tight_layout()\n    plt.savefig(out_name, dpi=200, bbox_inches=\"tight\")\n    # plt.show()\n    print(f\"Saved figure to {out_name}\")\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "run_instructions": "Run: python cricket_projectile_kinematics.py\nThis will generate and save 'projectile_motion_cricket_kinematics.png' in the working directory.",
      "python_packages": [
        "numpy",
        "matplotlib"
      ],
      "r_packages": [],
      "latex_requires": []
    }
  },
  {
    "ok": true,
    "topic": "explain me projectile motion using cricket",
    "slide_id": 6,
    "slide_name": "Role of Gravity in Projectile Motion",
    "workdir": "/home/dikshant-kukreja/Desktop/extramarks/viz_outputs/explain_me_projectile_motion_using_cricket/06_Role_of_Gravity_in_Projectile_Motion",
    "language": "python",
    "filename": "cricket_gravity_projectile.py",
    "run_exit_code": 0,
    "stdout": "",
    "stderr": "",
    "saved_artifacts": [
      "cricket_gravity_projectile.pdf",
      "cricket_gravity_projectile.png"
    ],
    "model_json": {
      "language": "python",
      "filename": "cricket_gravity_projectile.py",
      "code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef main():\n    # Parameters\n    g = 9.8  # m/s^2\n    v0 = 35.0  # initial speed (m/s), typical hard hit/throw\n    angle_deg = 50  # launch angle relative to horizontal (degrees)\n    theta = np.deg2rad(angle_deg)\n    y0 = 0.0\n\n    # Time of flight under gravity (from y0 back to ground y=0)\n    T = (2 * v0 * np.sin(theta)) / g\n    t = np.linspace(0, T, 500)\n\n    # Trajectory with gravity\n    x = v0 * np.cos(theta) * t\n    y = y0 + v0 * np.sin(theta) * t - 0.5 * g * t**2\n\n    # Hypothetical straight-line path without gravity (same initial velocity)\n    x_ng = v0 * np.cos(theta) * t\n    y_ng = y0 + v0 * np.sin(theta) * t\n\n    # Apex (highest point) where vy = 0\n    t_apex = v0 * np.sin(theta) / g\n    x_apex = v0 * np.cos(theta) * t_apex\n    y_apex = y0 + v0 * np.sin(theta) * t_apex - 0.5 * g * t_apex**2\n\n    # Create figure\n    fig, ax = plt.subplots(figsize=(10, 6))\n\n    # Plot trajectories\n    ax.plot(x, y, color=\"#2d8659\", lw=3, label=\"With gravity (g = 9.8 m/s²)\")\n    ax.plot(x_ng, y_ng, color=\"#ff8c00\", lw=2.5, ls=\"--\", label=\"Without gravity\")\n\n    # Ground line\n    x_max = max(x.max(), x_ng.max())\n    y_top = max(y.max(), y_ng.max())\n    ax.axhline(0, color=\"gray\", lw=1)\n\n    # Mark release point\n    ax.plot([0], [0], marker=\"o\", color=\"#2d8659\", ms=6)\n    ax.text(0, -3, \"Bat meets ball\", ha=\"left\", va=\"top\", fontsize=10)\n\n    # Apex marker and annotation\n    ax.plot([x_apex], [y_apex], marker=\"o\", color=\"#0a3\", ms=6)\n    ax.annotate(\n        \"Highest point (vy = 0)\",\n        xy=(x_apex, y_apex),\n        xytext=(x_apex + 0.06 * x_max, y_apex + 8),\n        arrowprops=dict(arrowstyle=\"->\", color=\"black\"),\n        fontsize=11,\n    )\n\n    # Vertical velocity component arrows to show gravity's effect\n    scale = 0.15  # converts m/s to plotted meters for arrow length\n    times = [0.15 * T, t_apex, 0.85 * T]\n    for ti in times:\n        xi = v0 * np.cos(theta) * ti\n        yi = y0 + v0 * np.sin(theta) * ti - 0.5 * g * ti**2\n        vyi = v0 * np.sin(theta) - g * ti\n        y_end = yi + scale * vyi\n        # Draw vertical velocity arrow (up early, zero at apex, down late)\n        if abs(vyi) > 1e-6:\n            ax.annotate(\n                \"\",\n                xy=(xi, y_end),\n                xytext=(xi, yi),\n                arrowprops=dict(arrowstyle=\"->\", color=\"#1f77b4\", lw=2),\n            )\n        else:\n            ax.plot([xi], [yi], marker=\"s\", color=\"#1f77b4\", ms=5)\n\n    # Labels near velocity arrows\n    xi1 = v0 * np.cos(theta) * times[0]\n    yi1 = y0 + v0 * np.sin(theta) * times[0] - 0.5 * g * times[0] ** 2\n    ax.text(\n        xi1 + 0.02 * x_max,\n        yi1 + 3,\n        \"Upward vy\\nslows down\",\n        color=\"#1f77b4\",\n        fontsize=10,\n    )\n    xi3 = v0 * np.cos(theta) * times[2]\n    yi3 = y0 + v0 * np.sin(theta) * times[2] - 0.5 * g * times[2] ** 2\n    ax.text(\n        xi3 + 0.02 * x_max,\n        yi3 - 8,\n        \"Downward vy\\nspeeds up\",\n        color=\"#1f77b4\",\n        fontsize=10,\n        va=\"top\",\n    )\n\n    # Gravity arrow and label\n    ax.annotate(\n        \"Gravity pulls down\\n(g = 9.8 m/s²)\",\n        xy=(0.06 * x_max, 0.85 * y_top),\n        xytext=(0.06 * x_max, 0.85 * y_top - 0.28 * y_top),\n        arrowprops=dict(arrowstyle=\"-|>\", lw=2, color=\"black\"),\n        ha=\"center\",\n        va=\"center\",\n        fontsize=11,\n    )\n\n    # Annotation for no-gravity straight line\n    idx = int(0.7 * len(x_ng))\n    ax.annotate(\n        \"Without gravity:\\nstraight-line flight,\\nnever returns to ground\",\n        xy=(x_ng[idx], y_ng[idx]),\n        xytext=(x_max * 0.55, y_top * 0.6),\n        arrowprops=dict(arrowstyle=\"->\", color=\"#ff8c00\"),\n        fontsize=10,\n        color=\"#ff8c00\",\n    )\n\n    # Aesthetics\n    ax.set_xlim(-2, x_max * 1.05)\n    ax.set_ylim(-5, y_top * 1.15)\n    ax.set_xlabel(\"Horizontal distance (m)\", fontsize=12)\n    ax.set_ylabel(\"Height (m)\", fontsize=12)\n    ax.set_title(\"Role of Gravity in Projectile Motion (Cricket)\", fontsize=14)\n    ax.legend(loc=\"upper right\", frameon=False)\n    ax.grid(True, alpha=0.25, ls=\"--\")\n\n    fig.tight_layout()\n    fig.savefig(\"cricket_gravity_projectile.png\", dpi=200)\n    fig.savefig(\"cricket_gravity_projectile.pdf\")\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "run_instructions": "Run: python cricket_gravity_projectile.py. This will save 'cricket_gravity_projectile.png' and 'cricket_gravity_projectile.pdf' in the working directory.",
      "python_packages": [
        "numpy",
        "matplotlib"
      ],
      "r_packages": [],
      "latex_requires": []
    }
  },
  {
    "ok": true,
    "topic": "explain me projectile motion using cricket",
    "slide_id": 1,
    "slide_name": "Definition of Projectile Motion",
    "workdir": "/home/dikshant-kukreja/Desktop/extramarks/viz_outputs/explain_me_projectile_motion_using_cricket/01_Definition_of_Projectile_Motion",
    "language": "python",
    "filename": "projectile_cricket.py",
    "run_exit_code": 0,
    "stdout": "Saved figure to projectile_cricket.png\n",
    "stderr": "",
    "saved_artifacts": [
      "projectile_cricket.png"
    ],
    "model_json": {
      "language": "python",
      "filename": "projectile_cricket.py",
      "code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle\n\n# Parameters\ng = 9.81  # gravity (m/s^2)\nv0 = 32.0  # initial speed of the cricket ball (m/s)\nangle_deg = 35.0  # launch angle in degrees\nangle = np.deg2rad(angle_deg)\n\n# Air properties and ball properties for drag model\nrho = 1.225  # air density (kg/m^3)\nCd = 0.5     # drag coefficient for a roughly spherical ball\nr = 0.036    # radius of a cricket ball (m)\nA = np.pi * r**2  # cross-sectional area (m^2)\nm = 0.156    # mass of a cricket ball (kg)\n\nk = 0.5 * rho * Cd * A / m  # drag acceleration constant\n\n# Ideal (no air resistance) trajectory\nT_ideal = 2 * v0 * np.sin(angle) / g\nT_plot = T_ideal\n\nt_ideal = np.linspace(0, T_ideal, 400)\nx_ideal = v0 * np.cos(angle) * t_ideal\ny_ideal = v0 * np.sin(angle) * t_ideal - 0.5 * g * t_ideal**2\n\n# Drag trajectory (numerical integration - simple Euler method)\ndt = 0.002\nvx = v0 * np.cos(angle)\nvy = v0 * np.sin(angle)\nx, y = 0.0, 0.0\nx_drag_list = [x]\ny_drag_list = [y]\n\nx_land_drag = None\n\nfor i in range(int(20 / dt)):  # cap at 20 s as a safe upper bound\n    v = np.hypot(vx, vy)\n    ax = -k * v * vx\n    ay = -g - k * v * vy\n\n    # Update velocities\n    vx += ax * dt\n    vy += ay * dt\n    # Update positions\n    x_new = x + vx * dt\n    y_new = y + vy * dt\n\n    x_drag_list.append(x_new)\n    y_drag_list.append(y_new)\n\n    if y > 0 and y_new <= 0:\n        # Linear interpolation to find a better landing x at y=0\n        frac = y / (y - y_new)\n        x_land_drag = x + frac * (x_new - x)\n        break\n\n    x, y = x_new, y_new\n\nx_drag = np.array(x_drag_list)\ny_drag = np.array(y_drag_list)\n\n# Landing points\nx_land_ideal = x_ideal[-1]\nif x_land_drag is None:\n    x_land_drag = x_drag[-1]\n\n# Apex (ideal)\napex_idx = np.argmax(y_ideal)\napex_x = x_ideal[apex_idx]\napex_y = y_ideal[apex_idx]\n\n# Figure\nplt.figure(figsize=(10, 6))\n\n# Ground line\nxmin_plot = -1.0\nxmax_plot = max(x_land_ideal, x_land_drag) * 1.05\nplt.plot([xmin_plot, xmax_plot], [0, 0], color=\"#5a8f3d\", lw=3, solid_capstyle='butt', alpha=0.8, label=\"Ground\")\n\n# Wickets (simple drawing to anchor the cricket context)\nstump_width = 0.03\nstump_height = 0.71\nstump_gap = 0.09\nwicket_x0 = -0.6\nwicket_color = '#8b5a2b'\nfor i in range(3):\n    rect = Rectangle((wicket_x0 + i * stump_gap, 0), stump_width, stump_height, facecolor=wicket_color, edgecolor='black', zorder=5)\n    plt.gca().add_patch(rect)\n# Bails\nbail_height = stump_height + 0.03\nbail_len = stump_gap - 0.02\nbail_thick = 0.015\nbail1 = Rectangle((wicket_x0 + 0.01, bail_height), bail_len, bail_thick, facecolor=wicket_color, edgecolor='black', zorder=6)\nbail2 = Rectangle((wicket_x0 + stump_gap + 0.01, bail_height), bail_len, bail_thick, facecolor=wicket_color, edgecolor='black', zorder=6)\nplt.gca().add_patch(bail1)\nplt.gca().add_patch(bail2)\n\n# Plot trajectories\nplt.plot(x_ideal, y_ideal, color=\"#1f77b4\", lw=2.5, label=\"No air resistance (parabola)\")\nplt.plot(x_drag, y_drag, color=\"#ff7f0e\", lw=2.5, ls='--', label=\"With air resistance\")\n\n# Annotate initial velocity components\norigin = np.array([0.0, 0.0])\nlen_scale = 0.6  # scale for arrow lengths for clarity\nv0x = v0 * np.cos(angle)\nv0y = v0 * np.sin(angle)\n\nplt.arrow(0, 0, len_scale * np.cos(angle), len_scale * np.sin(angle),\n          head_width=0.05, head_length=0.08, fc='#2ca02c', ec='#2ca02c', length_includes_head=True)\nplt.text(0.05, 0.08, f\"Initial speed v0 = {v0:.0f} m/s\\n(angle {angle_deg:.0f}°)\", color='#2ca02c')\n\n# Component arrows\nplt.arrow(0, 0, len_scale, 0, head_width=0.04, head_length=0.06, fc='#2ca02c', ec='#2ca02c', alpha=0.8, length_includes_head=True)\nplt.text(len_scale + 0.05, 0.02, \"Horizontal component v0 cos(θ)\\n(approx. constant without drag)\", color='#2ca02c', va='bottom')\n\nplt.arrow(0, 0, 0, len_scale * np.sin(angle), head_width=0.04, head_length=0.06, fc='#2ca02c', ec='#2ca02c', alpha=0.8, length_includes_head=True)\nplt.text(0.02, len_scale * np.sin(angle) + 0.05, \"Vertical component v0 sin(θ)\\n(changes due to gravity)\", color='#2ca02c', va='bottom')\n\n# Gravity annotation\nplt.arrow(xmin_plot + 0.1, apex_y * 0.9, 0, -0.4, head_width=0.05, head_length=0.08, fc='k', ec='k', length_includes_head=True)\nplt.text(xmin_plot + 0.15, apex_y * 0.9 - 0.2, \"Gravity g\\nacts downward\", va='center')\n\n# Apex annotation (ideal)\nplt.plot(apex_x, apex_y, 'o', color='#1f77b4')\nplt.annotate(\"Highest point\\n(vertical speed = 0)\",\n             xy=(apex_x, apex_y), xytext=(apex_x + 5, apex_y + 5),\n             arrowprops=dict(arrowstyle='->', color='#1f77b4'), color='#1f77b4')\n\n# Landing points\nplt.plot([x_land_ideal], [0], marker='o', color='#1f77b4')\nplt.text(x_land_ideal, -0.4, \"Landing (no air)\", color='#1f77b4', ha='center', va='top')\n\nplt.plot([x_land_drag], [0], marker='o', color='#ff7f0e')\nplt.text(x_land_drag, -0.8, \"Landing (with air)\\n(shorter range)\", color='#ff7f0e', ha='center', va='top')\n\n# Context label\ntitle = \"Projectile motion in cricket: a lofted shot\"\nplt.title(title)\nplt.xlabel(\"Horizontal distance (m)\")\nplt.ylabel(\"Height (m)\")\nplt.legend(loc='upper right')\n\n# Set limits and aesthetics\nymax_plot = max(np.max(y_ideal), np.max(y_drag)) * 1.15\nplt.xlim(xmin_plot, xmax_plot)\nplt.ylim(-1.2, ymax_plot)\nplt.grid(True, alpha=0.2)\n\nplt.tight_layout()\n\n# Save figure\noutfile = \"projectile_cricket.png\"\nplt.savefig(outfile, dpi=200)\nprint(f\"Saved figure to {outfile}\")\n",
      "run_instructions": "Run: python projectile_cricket.py. This will generate 'projectile_cricket.png' in the working directory.",
      "python_packages": [
        "numpy",
        "matplotlib"
      ],
      "r_packages": [],
      "latex_requires": []
    }
  },
  {
    "ok": true,
    "topic": "explain me projectile motion using cricket",
    "slide_id": 10,
    "slide_name": "Vector Representation and Resolution",
    "workdir": "/home/dikshant-kukreja/Desktop/extramarks/viz_outputs/explain_me_projectile_motion_using_cricket/10_Vector_Representation_and_Resolution",
    "language": "python",
    "filename": "cricket_vector_resolution.py",
    "run_exit_code": 0,
    "stdout": "Saved figure to cricket_vector_resolution.png\n",
    "stderr": "",
    "saved_artifacts": [
      "cricket_vector_resolution.png"
    ],
    "model_json": {
      "language": "python",
      "filename": "cricket_vector_resolution.py",
      "code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Arc, Circle, Rectangle\n\n\ndef main():\n    # Parameters\n    v = 20.0  # m/s\n    theta_deg = 30.0  # degrees\n    theta = np.deg2rad(theta_deg)\n    g = 9.81  # m/s^2\n\n    # Components\n    vx = v * np.cos(theta)\n    vy = v * np.sin(theta)\n\n    # Trajectory (no air resistance)\n    T = 2 * vy / g\n    t = np.linspace(0, T, 300)\n    x = vx * t\n    y = vy * t - 0.5 * g * t**2\n\n    R = vx * T\n    H = vy**2 / (2 * g)\n\n    # Figure setup\n    fig, ax = plt.subplots(figsize=(10, 6))\n\n    # Ground line\n    ax.axhline(0, color='0.7', lw=1)\n\n    # Plot trajectory\n    ax.plot(x, y, color='0.2', lw=2, ls='--')\n\n    # Initial velocity vector and its resolution triangle\n    # Arrow for resultant velocity v\n    head_w = 0.6\n    head_l = 1.2\n    ax.arrow(0, 0, vx, vy, length_includes_head=True, head_width=head_w, head_length=head_l,\n             fc='seagreen', ec='seagreen', lw=2)\n\n    # Arrow for horizontal component vx\n    ax.arrow(0, 0, vx, 0, length_includes_head=True, head_width=head_w*0.85, head_length=head_l*0.85,\n             fc='royalblue', ec='royalblue', lw=2)\n\n    # Arrow for vertical component vy (drawn from tip of vx)\n    ax.arrow(vx, 0, 0, vy, length_includes_head=True, head_width=head_w*0.85, head_length=head_l*0.85,\n             fc='darkorange', ec='darkorange', lw=2)\n\n    # Angle arc at origin\n    arc_r = 4.5\n    arc = Arc((0, 0), 2*arc_r, 2*arc_r, angle=0, theta1=0, theta2=theta_deg, color='0.4', lw=1.5)\n    ax.add_patch(arc)\n    ax.text(arc_r*0.85*np.cos(theta/2), arc_r*0.85*np.sin(theta/2), r\"$\\theta=30^\\circ$\", color='0.3',\n            ha='center', va='center')\n\n    # Labels for vectors\n    ax.text(vx*0.55, vy*0.55, r\"$\\vec{v}$ = 20 m/s\", color='seagreen', fontsize=12,\n            ha='left', va='bottom', bbox=dict(boxstyle='round,pad=0.2', fc='white', ec='seagreen', alpha=0.8))\n    ax.text(vx*0.5, -0.9, r\"$v_x = v\\cos\\theta = %.1f$ m/s\" % vx, color='royalblue', fontsize=11,\n            ha='center', va='top')\n    ax.text(vx + 0.6, vy*0.5, r\"$v_y = v\\sin\\theta = %.1f$ m/s\" % vy, color='darkorange', fontsize=11,\n            ha='left', va='center')\n\n    # Helpful notes linking vectors to motion\n    note = (\n        \"Resolve initial velocity into components:\\n\"\n        \"- Horizontal: constant $v_x$\\n\"\n        \"- Vertical: changes under gravity $g$\"\n    )\n    ax.text(R*0.58, H*1.6 + 2, note, fontsize=11, color='0.2', ha='left', va='top',\n            bbox=dict(boxstyle='round,pad=0.4', fc='white', ec='0.5', alpha=0.9))\n\n    # Minimal cricket context: ball at launch, simple stumps in the distance\n    ball = Circle((0, 0), 0.35, color='crimson', ec='black', zorder=5)\n    ax.add_patch(ball)\n    # Stumps near the approximate range\n    stump_x = R * 0.95\n    stump_w = 0.25\n    stump_h = 1.0\n    for i in range(3):\n        ax.add_patch(Rectangle((stump_x + i*(stump_w*1.1), 0), stump_w, stump_h, color='#C09050', ec='saddlebrown'))\n\n    # Axes labels and title\n    ax.set_xlabel('Horizontal distance x (m)')\n    ax.set_ylabel('Vertical height y (m)')\n    ax.set_title('Cricket Projectile: Vector Representation and Resolution')\n\n    # Limits and aspect\n    x_max = max(R*1.1, vx*1.15 + 2)\n    y_max = max(H*2.2, vy*1.15 + 2)\n    ax.set_xlim(-1.5, x_max)\n    ax.set_ylim(-1.5, y_max)\n    ax.set_aspect('equal', adjustable='box')\n\n    # Clean look\n    ax.spines['top'].set_visible(False)\n    ax.spines['right'].set_visible(False)\n    ax.grid(alpha=0.15)\n\n    # Save\n    out_name = 'cricket_vector_resolution.png'\n    plt.tight_layout()\n    plt.savefig(out_name, dpi=200)\n    print(f'Saved figure to {out_name}')\n\n\nif __name__ == '__main__':\n    main()\n",
      "run_instructions": "Run: python cricket_vector_resolution.py. The script will generate and save cricket_vector_resolution.png in the working directory.",
      "python_packages": [
        "matplotlib",
        "numpy"
      ],
      "r_packages": [],
      "latex_requires": []
    }
  },
  {
    "ok": false,
    "topic": "explain me projectile motion using cricket",
    "slide_id": 12,
    "slide_name": "Real-World Applications of Projectile Motion",
    "workdir": "/home/dikshant-kukreja/Desktop/extramarks/viz_outputs/explain_me_projectile_motion_using_cricket/12_Real-World_Applications_of_Projectile_Motion",
    "language": "python",
    "filename": "cricket_projectile_applications.py",
    "run_exit_code": 1,
    "stdout": "",
    "stderr": "  File \u001b[35m\"/home/dikshant-kukreja/Desktop/extramarks/viz_outputs/explain_me_projectile_motion_using_cricket/12_Real-World_Applications_of_Projectile_Motion/cricket_projectile_applications.py\"\u001b[0m, line \u001b[35m115\u001b[0m\n    ax.plot(data[\"x\"], data[\"y\"], color=data[\"color\"], lw=2.8, label=f\"{data['label']} (v={data['v']:.0f} m/s, \u0003f={data['theta']:.0f}\n\u001b[1;35mSyntaxError\u001b[0m: \u001b[35msource code cannot contain null bytes\u001b[0m\n",
    "saved_artifacts": [],
    "model_json": {
      "language": "python",
      "filename": "cricket_projectile_applications.py",
      "code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle\n\n# ----------------------------\n# Parameters and helpers\n# ----------------------------\ng = 9.81  # m/s^2\nh0 = 1.0  # initial ball height at impact (m)\n\n\ndef trajectory(v, theta_deg, g=9.81, h0=1.0, n=250):\n    \"\"\"Compute x(t), y(t) and time of flight for a projectile launched from height h0.\n    v: launch speed (m/s)\n    theta_deg: launch angle (degrees)\n    Returns: x, y, t_flight\n    \"\"\"\n    theta = np.deg2rad(theta_deg)\n    a = -0.5 * g\n    b = v * np.sin(theta)\n    c = h0\n    # Solve a t^2 + b t + c = 0 for positive root. With a < 0, use (-b - sqrt(D))/(2a)\n    D = b**2 - 4 * a * c\n    t_flight = (-b - np.sqrt(D)) / (2 * a)\n    t = np.linspace(0, t_flight, n)\n    x = v * np.cos(theta) * t\n    y = h0 + v * np.sin(theta) * t + a * (2 * t**2)  # since a = -0.5g, a*(2 t^2) = -g t^2\n    return x, y, t_flight\n\n\n# ----------------------------\n# Scenarios (cricket-focused)\n# ----------------------------\nscenarios = [\n    {\"label\": \"Lofted shot\", \"v\": 28.0, \"theta\": 55.0, \"color\": \"tab:blue\"},\n    {\"label\": \"Flat drive\", \"v\": 26.0, \"theta\": 30.0, \"color\": \"tab:red\"},\n    {\"label\": \"Controlled chip\", \"v\": 22.0, \"theta\": 40.0, \"color\": \"tab:green\"},\n]\n\n# Same-angle, higher-speed comparison (equipment/design effect)\ncomparison = {\"label\": \"Same angle, higher speed\", \"v\": 30.0, \"theta\": 30.0, \"color\": \"0.3\", \"style\": (0, (4, 3))}\n\n# Field and fielder parameters\nboundary_x = 65.0  # typical rope distance (m)\nfielder_x = 70.0   # deep fielder starting position (m)\nfielder_speed = 6.0  # m/s reachable speed\n\n# ----------------------------\n# Compute trajectories\n# ----------------------------\ntraj_data = []\nmax_x = boundary_x\nmax_y = 0.0\n\nfor sc in scenarios:\n    x, y, tf = trajectory(sc[\"v\"], sc[\"theta\"], g=g, h0=h0)\n    landing_x = x[-1]\n    window_min = fielder_x - fielder_speed * tf\n    window_max = fielder_x + fielder_speed * tf\n    # Determine qualitative outcome\n    if landing_x >= boundary_x:\n        outcome = \"Six (clears boundary)\"\n        catchable = False\n    else:\n        catchable = (window_min <= landing_x <= window_max)\n        outcome = \"Catchable by this fielder\" if catchable else \"Likely lands in gap\"\n    traj_data.append({\n        \"label\": sc[\"label\"],\n        \"v\": sc[\"v\"],\n        \"theta\": sc[\"theta\"],\n        \"color\": sc[\"color\"],\n        \"x\": x,\n        \"y\": y,\n        \"t\": tf,\n        \"landing_x\": landing_x,\n        \"window\": (window_min, window_max),\n        \"outcome\": outcome,\n        \"catchable\": catchable,\n    })\n    max_x = max(max_x, np.max(x))\n    max_y = max(max_y, np.max(y))\n\n# Comparison curve\ncx, cy, ct = trajectory(comparison[\"v\"], comparison[\"theta\"], g=g, h0=h0)\nmax_x = max(max_x, np.max(cx))\nmax_y = max(max_y, np.max(cy))\n\n# ----------------------------\n# Plot\n# ----------------------------\nplt.figure(figsize=(11, 7))\nax = plt.gca()\n\n# Ground line\nax.axhline(0, color=\"k\", linewidth=1)\n\n# Boundary rope\nax.axvline(boundary_x, color=\"tab:purple\", linestyle=(0, (5, 5)), linewidth=2, alpha=0.9)\nax.text(boundary_x + 0.5, 0.3, \"Boundary rope (≈65 m)\", color=\"tab:purple\", fontsize=10, rotation=90, va=\"bottom\")\n\n# Fielder start and reachable window (draw once using the longest window for context?)\n# We'll draw per scenario as semi-transparent overlays to emphasize time-of-flight dependence.\nfor data in traj_data:\n    wmin, wmax = data[\"window\"]\n    width = max(0.0, wmax - wmin)\n    rect = Rectangle((wmin, 0), width, 1.2, color=\"gold\", alpha=0.18, ec=None)\n    ax.add_patch(rect)\n\n# Fielder marker\nax.scatter([fielder_x], [0], marker='^', s=110, color='goldenrod', edgecolor='k', zorder=5)\nax.text(fielder_x, 1.5, f\"Fielder start @ {fielder_x:.0f} m\", ha=\"center\", color='goldenrod', fontsize=10)\n\n# Plot trajectories\nfor data in traj_data:\n    ax.plot(data[\"x\"], data[\"y\"], color=data[\"color\"], lw=2.8, label=f\"{data['label']} (v={data['v']:.0f} m/s, \u0003f={data['theta']:.0f}\u0000b0)\")\n    # Landing marker and annotation\n    ax.plot([data[\"landing_x\"]], [0], marker='o', color=data[\"color\"], ms=7)\n    ann = f\"R={data['landing_x']:.1f} m\\nT={data['t']:.2f} s\\n{data['outcome']}\"\n    ax.annotate(ann,\n                xy=(data[\"landing_x\"], 0), xycoords='data',\n                xytext=(10, 25), textcoords='offset points',\n                fontsize=9, bbox=dict(boxstyle='round,pad=0.3', fc='white', ec=data[\"color\"], lw=1),\n                arrowprops=dict(arrowstyle='->', color=data[\"color\"], lw=1))\n\n# Comparison (equipment/bat speed effect) - same angle, higher speed\nax.plot(cx, cy, color=comparison[\"color\"], lw=2, ls=comparison[\"style\"], label=\"Same angle, higher bat speed \u0019e farther\")\nax.annotate(\"More bat speed\\n\u0019e longer range\",\n            xy=(cx[int(len(cx)*0.55)], cy[int(len(cy)*0.55)]), xycoords='data',\n            xytext=(40, 30), textcoords='offset points',\n            fontsize=10, color='0.2',\n            arrowprops=dict(arrowstyle='->', color='0.2'))\n\n# Styling\nax.set_xlim(0, max_x + 10)\nax.set_ylim(0, max(max_y + 5, 12))\nax.set_xlabel(\"Horizontal distance (m)\", fontsize=12)\nax.set_ylabel(\"Height (m)\", fontsize=12)\nax.set_title(\"Real-World Applications of Projectile Motion in Cricket\", fontsize=14, weight='bold')\nax.grid(True, which='both', ls='--', lw=0.6, alpha=0.4)\n\n# Legend with an extra patch handle for the window explanation\nfrom matplotlib.lines import Line2D\nwindow_proxy = Rectangle((0, 0), 1, 1, color='gold', alpha=0.18, ec='none')\nhandles, labels = ax.get_legend_handles_labels()\nhandles.append(window_proxy)\nlabels.append(\"Fielder reachable before landing (depends on T)\")\nlegend = ax.legend(handles, labels, loc='upper right', frameon=True)\n\n# Context text box\ncontext_text = (\n    \"How this physics informs the game:\\n\"\n    \"- Field placement: use hang time (T) to size catch windows.\\n\"\n    \"- Match decisions: predict if a shot is catchable or clears the rope.\\n\"\n    \"- Equipment design: higher launch speed pushes the same-angle shot farther.\"\n)\nax.text(0.01, 0.98, context_text, transform=ax.transAxes, va='top', ha='left', fontsize=10,\n        bbox=dict(boxstyle='round,pad=0.4', fc='white', ec='0.7'))\n\n# Save figure\nout_path = \"cricket_projectile_motion_applications.png\"\nplt.tight_layout()\nplt.savefig(out_path, dpi=150)\nprint(f\"Saved figure to {out_path}\")\n",
      "run_instructions": "Run: python3 cricket_projectile_applications.py\nThis will save 'cricket_projectile_motion_applications.png' in the working directory.",
      "python_packages": [
        "numpy",
        "matplotlib"
      ],
      "r_packages": [],
      "latex_requires": []
    }
  },
  {
    "ok": true,
    "topic": "explain me projectile motion using cricket",
    "slide_id": 9,
    "slide_name": "Momentum and Energy Considerations",
    "workdir": "/home/dikshant-kukreja/Desktop/extramarks/viz_outputs/explain_me_projectile_motion_using_cricket/09_Momentum_and_Energy_Considerations",
    "language": "python",
    "filename": "cricket_projectile_energy_momentum.py",
    "run_exit_code": 0,
    "stdout": "Figure saved as cricket_projectile_energy_momentum.png\n",
    "stderr": "",
    "saved_artifacts": [
      "cricket_projectile_energy_momentum.png"
    ],
    "model_json": {
      "language": "python",
      "filename": "cricket_projectile_energy_momentum.py",
      "code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n# Parameters (cricket context)\ng = 9.81                  # gravitational acceleration (m/s^2)\nm = 0.156                # mass of a cricket ball (kg)\nv0 = 30.0                # initial speed (m/s) ~ fast throw/bowl\nangle_deg = 35.0         # launch angle (degrees)\ny0 = 1.5                 # release height (m)\n\n# Derived quantities\nangle = np.deg2rad(angle_deg)\nvx0 = v0 * np.cos(angle)\nvy0 = v0 * np.sin(angle)\n\n# Time of flight until the ball hits the ground (y=0)\n# Solve y(t) = y0 + vy0*t - 0.5*g*t^2 = 0 for t > 0\n# t = (vy0 + sqrt(vy0^2 + 2*g*y0)) / g\nt_flight = (vy0 + np.sqrt(vy0**2 + 2*g*y0)) / g\n\n# Time array\nN = 400\nt = np.linspace(0, t_flight, N)\n\n# Trajectory\nx = vx0 * t\ny = y0 + vy0 * t - 0.5 * g * t**2\n\n# Velocities and momentum components\nvx = np.full_like(t, vx0)\nvy = vy0 - g * t\npx = m * vx\npy = m * vy\n\n# Energies (relative potential energy with ground at y=0)\nKE = 0.5 * m * (vx**2 + vy**2)\nPE = m * g * np.maximum(y, 0)  # clamp below ground to 0 for neatness near landing\nE_total = KE + PE\n\n# Key points: apex (vy = 0)\nt_apex = vy0 / g\nx_apex = vx0 * t_apex\ny_apex = y0 + vy0 * t_apex - 0.5 * g * t_apex**2\n\n# Figure layout\nplt.rcParams.update({\n    'font.size': 11,\n    'axes.labelsize': 12,\n    'axes.titlesize': 13,\n    'legend.fontsize': 10\n})\n\nfig = plt.figure(figsize=(12, 7))\nfrom matplotlib.gridspec import GridSpec\n\ngs = GridSpec(2, 2, width_ratios=[1.2, 1], height_ratios=[1, 1], wspace=0.25, hspace=0.32)\nax_traj = fig.add_subplot(gs[:, 0])\nax_E = fig.add_subplot(gs[0, 1])\nax_p = fig.add_subplot(gs[1, 1])\n\n# 1) Trajectory with momentum vectors\nax_traj.plot(x, y, color='tab:blue', lw=2, label='Ball trajectory')\nax_traj.axhline(0, color='k', lw=1, alpha=0.5)\n\n# Mark release, apex, and landing\nax_traj.plot([x[0]], [y[0]], marker='o', color='tab:green', label='Release')\nax_traj.plot([x_apex], [y_apex], marker='^', color='tab:purple', label='Apex')\nax_traj.plot([x[-1]], [0], marker='s', color='tab:red', label='Impact')\n\n# Momentum vectors along the path (aligned with velocity)\n# Scale vectors so they are visible in data units\nn_arrows = 8\nidxs = np.linspace(10, N-10, n_arrows, dtype=int)\nLscale = 8.0  # meters for visual scaling of vectors\nu = (vx[idxs] / v0) * Lscale\nv = (vy[idxs] / v0) * Lscale\nax_traj.quiver(x[idxs], y[idxs], u, v, angles='xy', scale_units='xy', scale=1,\n               color='tab:orange', width=0.004, alpha=0.9, label='Momentum direction')\n\n# Labels and annotations\nax_traj.set_title('(A) Projectile path with momentum vectors')\nax_traj.set_xlabel('Horizontal distance x (m)')\nax_traj.set_ylabel('Height y (m)')\nax_traj.grid(True, ls='--', alpha=0.3)\n\n# Text annotations on trajectory\nax_traj.annotate('Apex (vy = 0)\\nKE minimized, PE maximized',\n                 xy=(x_apex, y_apex), xytext=(x_apex + 10, y_apex + 10),\n                 arrowprops=dict(arrowstyle='->', color='gray'), fontsize=10)\nax_traj.text(0.02, 0.95,\n             'Ignoring air resistance:\\n- Horizontal momentum (px) constant\\n- Momentum always along velocity',\n             transform=ax_traj.transAxes, va='top', ha='left', fontsize=10,\n             bbox=dict(boxstyle='round,pad=0.3', facecolor='white', alpha=0.8, ec='gray'))\n\n# Set reasonable limits\nx_margin = max(10, 0.05 * x.max())\ny_margin = max(2, 0.1 * (max(y.max(), y0)))\nax_traj.set_xlim(-2, x.max() + x_margin)\nax_traj.set_ylim(-2, max(y.max(), y0) + y_margin)\nax_traj.legend(loc='lower right')\n\n# 2) Energies vs time\nax_E.plot(t, KE, color='tab:red', lw=2, label='Kinetic energy (KE)')\nax_E.plot(t, PE, color='tab:green', lw=2, label='Potential energy (PE)')\nax_E.plot(t, E_total, color='tab:blue', lw=2, ls='--', label='Total energy (KE + PE)')\nax_E.set_title('(B) Energy exchange during flight')\nax_E.set_xlabel('Time t (s)')\nax_E.set_ylabel('Energy (J)')\nax_E.grid(True, ls='--', alpha=0.3)\nax_E.legend(loc='best')\nax_E.annotate('Energy trades between KE and PE\\nTotal remains constant',\n              xy=(t_apex, E_total[np.searchsorted(t, t_apex)]),\n              xytext=(t_apex + 0.5, np.max(E_total)*0.9),\n              arrowprops=dict(arrowstyle='->', color='gray'), fontsize=10)\n\n# 3) Momentum components vs time\nax_p.plot(t, px, color='tab:orange', lw=2, ls='-', label='px (horizontal) — constant')\nax_p.plot(t, py, color='tab:purple', lw=2, label='py (vertical) — changes linearly')\nax_p.axhline(0, color='k', lw=1, alpha=0.4)\nax_p.set_title('(C) Momentum components')\nax_p.set_xlabel('Time t (s)')\nax_p.set_ylabel('Momentum (kg·m/s)')\nax_p.grid(True, ls='--', alpha=0.3)\nax_p.legend(loc='best')\n\n# Global title with context\nfig.suptitle('Projectile Motion of a Cricket Ball: Momentum and Energy\\n'\n             f'm = {m:.3f} kg, v0 = {v0:.0f} m/s, angle = {angle_deg:.0f}°, release height = {y0:.1f} m, g = {g:.2f} m/s²',\n             y=0.98, fontsize=14)\n\n# Save figure\noutfile = 'cricket_projectile_energy_momentum.png'\nplt.savefig(outfile, dpi=300, bbox_inches='tight')\nplt.close(fig)\n\nprint(f'Figure saved as {outfile}')\n",
      "run_instructions": "Run: python cricket_projectile_energy_momentum.py\nThis will save cricket_projectile_energy_momentum.png in the working directory.",
      "python_packages": [
        "numpy",
        "matplotlib"
      ],
      "r_packages": [],
      "latex_requires": []
    }
  },
  {
    "ok": true,
    "topic": "explain me projectile motion using cricket",
    "slide_id": 3,
    "slide_name": "Independence of Horizontal and Vertical Motion",
    "workdir": "/home/dikshant-kukreja/Desktop/extramarks/viz_outputs/explain_me_projectile_motion_using_cricket/03_Independence_of_Horizontal_and_Vertical_Motion",
    "language": "python",
    "filename": "cricket_projectile_independence.py",
    "run_exit_code": 0,
    "stdout": "",
    "stderr": "",
    "saved_artifacts": [
      "cricket_projectile_independence.png"
    ],
    "model_json": {
      "language": "python",
      "filename": "cricket_projectile_independence.py",
      "code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n# Parameters\ng = 9.81  # m/s^2\ny0 = 1.5  # release height (m), approximate shoulder height of a fielder\nvx = 18.0  # horizontal speed (m/s), same for left-panel throws\n\n# Different vertical launch speeds for throws with the same horizontal speed\nvy_list = [3.0, 8.0, 13.0]  # low, flat, lofted\ncolors = ['tab:green', 'tab:orange', 'tab:blue']\nlabels = [\n    'Low throw (vy0 = 3 m/s)',\n    'Flat throw (vy0 = 8 m/s)',\n    'Lofted throw (vy0 = 13 m/s)'\n]\n\n# Utility to compute flight time until the ball hits the ground (y=0)\ndef flight_time(vy0, y0=y0, g=g):\n    # Solve y0 + vy0 t - 0.5 g t^2 = 0 for positive root\n    return (vy0 + np.sqrt(vy0**2 + 2*g*y0)) / g\n\n# Prepare figure\nfig, axes = plt.subplots(1, 2, figsize=(12, 5))\n\n# LEFT PANEL: Same vx, different vy0\nax = axes[0]\n\n# Full trajectories for context\nt_flights = [flight_time(vy) for vy in vy_list]\n\nymax_marks = 0.0\nfor vy, c, lab in zip(vy_list, colors, labels):\n    tf = flight_time(vy)\n    t = np.linspace(0, tf, 300)\n    x = vx * t\n    y = y0 + vy * t - 0.5 * g * t**2\n    y = np.maximum(y, 0)\n    ax.plot(x, y, color=c, lw=2, label=lab)\n\n# Time-synchronized markers (up to earliest landing)\nt_sync = min(t_flights)\nt_marks = np.linspace(0, t_sync, 6)\n\n# Vertical guide lines at equal times (same x for all because vx is the same)\nfor t in t_marks:\n    x_mark = vx * t\n    ax.axvline(x_mark, color='0.85', lw=1, linestyle='--', zorder=0)\n\n# Place synchronized dots on each trajectory\nfor vy, c in zip(vy_list, colors):\n    x_marks = vx * t_marks\n    y_marks = y0 + vy * t_marks - 0.5 * g * t_marks**2\n    y_marks = np.maximum(y_marks, 0)\n    ymax_marks = max(ymax_marks, np.max(y_marks))\n    ax.plot(x_marks, y_marks, 'o', color=c, ms=4)\n\n# Annotations and styling\nax.axhline(0, color='saddlebrown', lw=2)\nax.set_xlim(0, vx * (t_sync + 0.25))\nax.set_ylim(0, max(ymax_marks + 1.0, y0 + 1.0))\nax.set_xlabel('Horizontal distance x (m)')\nax.set_ylabel('Height y (m)')\nax.set_title('Same vx, different vy: motions are independent')\nax.legend(loc='upper right', fontsize=8, frameon=False)\nax.text(0.03, 0.95, 'x(t) = vx · t (vx constant)', transform=ax.transAxes,\n        va='top', ha='left', fontsize=9,\n        bbox=dict(boxstyle='round', facecolor='white', alpha=0.85, lw=0))\nax.text(0.03, 0.88, 'Vertical dashed lines = same time for all balls', transform=ax.transAxes,\n        va='top', ha='left', fontsize=8, color='0.3')\nax.annotate('Gravity acts downward only (ay = -g)',\n            xy=(0.5 * vx * t_sync, y0 + 0.5),\n            xytext=(0.5 * vx * t_sync + 3, y0 + 3.5),\n            arrowprops=dict(arrowstyle='->', color='k'), fontsize=9)\nax.grid(True, color='0.9', linestyle='-')\n\n# RIGHT PANEL: Dropped ball vs horizontally thrown ball from same height\nax2 = axes[1]\n\nvx2 = 18.0  # horizontal speed for the throw\nvy0_drop = 0.0\nvy0_throw = 0.0\n\n# Both share the same vertical motion when vy0 is equal and gravity acts downward\nt_flight_drop = np.sqrt(2 * y0 / g)\nt = np.linspace(0, t_flight_drop, 250)\ny_shared = y0 - 0.5 * g * t**2\nx_throw = vx2 * t\nx_drop = np.zeros_like(t)\n\nax2.plot(x_throw, y_shared, color='tab:blue', lw=2, label='Horizontal throw (vx > 0, vy0 = 0)')\nax2.plot(x_drop, y_shared, color='tab:red', lw=2, label='Dropped ball (vx = 0, vy0 = 0)')\n\n# Time-synchronized markers and horizontal guides (same y at each time)\nt_marks2 = np.linspace(0, t_flight_drop, 6)\ny_marks2 = y0 - 0.5 * g * t_marks2**2\nx_marks_throw = vx2 * t_marks2\nx_marks_drop = np.zeros_like(t_marks2)\n\nfor yline in y_marks2:\n    ax2.axhline(yline, color='0.85', lw=1, linestyle='--', zorder=0)\nax2.plot(x_marks_throw, y_marks2, 'o', color='tab:blue', ms=4)\nax2.plot(x_marks_drop, y_marks2, 'o', color='tab:red', ms=4)\n\nax2.axhline(0, color='saddlebrown', lw=2)\nax2.set_xlim(-1, vx2 * t_flight_drop + 7)\nax2.set_ylim(0, y0 + 0.8)\nax2.set_xlabel('Horizontal distance x (m)')\nax2.set_title('Drop vs horizontal throw: same y(t), different x(t)')\nax2.legend(loc='upper right', fontsize=8, frameon=False)\nax2.text(0.03, 0.95, 'y(t) = y0 - 0.5 g t^2 (same for both)', transform=ax2.transAxes,\n         va='top', ha='left', fontsize=9,\n         bbox=dict(boxstyle='round', facecolor='white', alpha=0.85, lw=0))\nax2.annotate('Same vertical fall at equal times',\n             xy=(x_marks_throw[3], y_marks2[3]),\n             xytext=(x_marks_throw[3] + 2, y_marks2[3] + 0.35),\n             arrowprops=dict(arrowstyle='->', color='k'), fontsize=9)\nax2.grid(True, color='0.9', linestyle='-')\n\n# Titles and footnote\nfig.suptitle('Independence of Horizontal and Vertical Motion — Cricket Ball', fontsize=14, y=0.98)\nfig.text(0.5, 0.02, 'Neglecting air resistance; g = 9.81 m/s^2; release height = 1.5 m', ha='center', fontsize=9)\n\nplt.tight_layout(rect=[0, 0.04, 1, 0.95])\n\n# Save figure\noutname = 'cricket_projectile_independence.png'\nplt.savefig(outname, dpi=200, bbox_inches='tight')\n",
      "run_instructions": "1) Install Python 3 with numpy and matplotlib. 2) Run: python cricket_projectile_independence.py 3) The script saves cricket_projectile_independence.png in the working directory.",
      "python_packages": [
        "matplotlib",
        "numpy"
      ],
      "r_packages": [],
      "latex_requires": []
    }
  },
  {
    "ok": true,
    "topic": "explain me projectile motion using cricket",
    "slide_id": 11,
    "slide_name": "Application of Mathematics in Projectile Motion",
    "workdir": "/home/dikshant-kukreja/Desktop/extramarks/viz_outputs/explain_me_projectile_motion_using_cricket/11_Application_of_Mathematics_in_Projectile_Motion",
    "language": "python",
    "filename": "cricket_projectile_motion.py",
    "run_exit_code": 0,
    "stdout": "Saved figure to cricket_projectile_motion.png\n",
    "stderr": "",
    "saved_artifacts": [
      "cricket_projectile_motion.png"
    ],
    "model_json": {
      "language": "python",
      "filename": "cricket_projectile_motion.py",
      "code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.gridspec import GridSpec\n\n# Parameters for the cricket shot (no air resistance)\ng = 9.81  # m/s^2 (gravity)\nv0 = 35.0  # m/s, typical lofted cricket shot speed\nangle_deg = 35.0  # launch angle in degrees\nangle = np.deg2rad(angle_deg)\n\n# Key projectile quantities\nT = 2 * v0 * np.sin(angle) / g  # time of flight (s)\nR = (v0**2) * np.sin(2 * angle) / g  # range (m)\nH = (v0**2) * (np.sin(angle)**2) / (2 * g)  # max height (m)\n\n# Trajectory points\nnum = 400\nt = np.linspace(0, T, num)\nx = v0 * np.cos(angle) * t\ny = v0 * np.sin(angle) * t - 0.5 * g * t**2\n# Ensure ground is y >= 0 for plotting (avoid tiny negative due to float error)\ny = np.maximum(y, 0)\n\n# Apex point\nt_apex = v0 * np.sin(angle) / g\nx_apex = v0 * np.cos(angle) * t_apex\ny_apex = H\n\n# Prepare angle sweep for insights on optimization\ntheta_deg = np.linspace(5, 80, 400)\ntheta = np.deg2rad(theta_deg)\nR_theta = (v0**2) * np.sin(2 * theta) / g\nT_theta = 2 * v0 * np.sin(theta) / g\nH_theta = (v0**2) * (np.sin(theta)**2) / (2 * g)\n\n# Figure layout\nplt.rcParams.update({\n    'font.size': 10,\n    'axes.grid': True,\n    'grid.alpha': 0.3\n})\nfig = plt.figure(figsize=(12, 6), constrained_layout=True)\ngs = GridSpec(3, 4, figure=fig, width_ratios=[2.2, 2.2, 1.2, 1.2], height_ratios=[1, 1, 1])\nax_main = fig.add_subplot(gs[:, :2])\nax_r = fig.add_subplot(gs[0, 2:])\nax_t = fig.add_subplot(gs[1, 2:])\nax_h = fig.add_subplot(gs[2, 2:])\n\n# Main trajectory plot (left)\nax_main.plot(x, y, lw=3, color='#1f77b4', label='Ball trajectory')\nax_main.set_title('Projectile Motion of a Cricket Shot (no air resistance)')\nax_main.set_xlabel('Horizontal distance x (m)')\nax_main.set_ylabel('Height y (m)')\n\n# Ground line\nax_main.axhline(0, color='k', lw=1)\n\n# Mark start (bat impact) and apex\nax_main.plot([0], [0], 'o', color='tab:green', ms=6)\nax_main.text(0.5, 0.5, 'Bat impact', color='tab:green')\nax_main.plot([x_apex], [y_apex], 'o', color='tab:orange', ms=6)\nax_main.annotate(f'Max height H = {H:.1f} m',\n                 xy=(x_apex, y_apex), xytext=(x_apex*0.6, y_apex*1.15),\n                 arrowprops=dict(arrowstyle='->', color='tab:orange'),\n                 bbox=dict(boxstyle='round,pad=0.3', fc='white', ec='tab:orange', alpha=0.8),\n                 color='tab:orange')\n\n# Range marker\nax_main.annotate('', xy=(R, 0), xytext=(0, 0),\n                 arrowprops=dict(arrowstyle='<->', color='tab:purple', lw=2))\nax_main.text(R*0.5, -0.05*max(1, H), f'Range R = {R:.1f} m', color='tab:purple', ha='center', va='top')\n\n# Initial velocity vector and its components (scaled for display)\nvec_len = 0.22 * R\nvx_dir = np.cos(angle)\nvy_dir = np.sin(angle)\n# Resultant v0 arrow\nax_main.annotate('', xy=(vec_len*vx_dir, vec_len*vy_dir), xytext=(0, 0),\n                 arrowprops=dict(arrowstyle='->', lw=2, color='tab:red'))\nax_main.text(vec_len*vx_dir*0.6, vec_len*vy_dir*0.65, f'v0 = {v0:.1f} m/s\\n(launch {angle_deg:.0f}°)', color='tab:red')\n# Component guides (dashed to axes)\nax_main.plot([vec_len*vx_dir, vec_len*vx_dir], [0, vec_len*vy_dir], ls='--', color='gray', lw=1)\nax_main.plot([0, vec_len*vx_dir], [vec_len*vy_dir, vec_len*vy_dir], ls='--', color='gray', lw=1)\nax_main.text(vec_len*vx_dir*0.5, -0.03*max(1, H), 'v0x = v0 cos(θ)', ha='center')\nax_main.text(-0.02*R, vec_len*vy_dir*0.5, 'v0y = v0 sin(θ)', va='center', rotation=90)\n\n# Impact speed vector near landing (magnitude ~ v0 for equal heights)\nimpact_anchor_x = R * 0.98\nimpact_anchor_y = 0\nax_main.annotate('',\n                 xy=(impact_anchor_x, impact_anchor_y),\n                 xytext=(impact_anchor_x - vec_len*vx_dir, impact_anchor_y - vec_len*vy_dir),\n                 arrowprops=dict(arrowstyle='->', lw=2, color='tab:red'))\nax_main.text(impact_anchor_x - vec_len*vx_dir*0.9, impact_anchor_y - vec_len*vy_dir*0.95,\n             f'Impact speed ≈ {v0:.1f} m/s', color='tab:red', ha='right', va='top')\n\n# Info box with computed values\ninfo = f\"Time of flight T = {T:.2f} s\\nMax height H = {H:.1f} m\\nRange R = {R:.1f} m\"\nax_main.text(0.02*R, 0.95*max(H, 1), info,\n             bbox=dict(boxstyle='round,pad=0.4', fc='white', ec='gray', alpha=0.9), va='top')\nax_main.text(0.02*R, 0.05*max(H, 1), 'Velocity arrows scaled for display', color='gray')\n\n# Limits and legend\nax_main.set_xlim(-0.02*R, R*1.08)\nax_main.set_ylim(0, max(H*1.3, 5))\nax_main.legend(loc='upper right')\n\n# Right column: How angle affects outcomes\nax_r.plot(theta_deg, R_theta, color='tab:purple', lw=2)\nax_r.axvline(angle_deg, color='gray', ls='--', lw=1)\nax_r.plot([angle_deg], [R], 'o', color='tab:purple')\nax_r.set_title('Range vs Launch Angle')\nax_r.set_ylabel('Range (m)')\nax_r.set_xticklabels([])\n\nax_t.plot(theta_deg, T_theta, color='tab:blue', lw=2)\nax_t.axvline(angle_deg, color='gray', ls='--', lw=1)\nax_t.plot([angle_deg], [T], 'o', color='tab:blue')\nax_t.set_title('Flight Time vs Launch Angle')\nax_t.set_ylabel('Time (s)')\nax_t.set_xticklabels([])\n\nax_h.plot(theta_deg, H_theta, color='tab:orange', lw=2)\nax_h.axvline(angle_deg, color='gray', ls='--', lw=1)\nax_h.plot([angle_deg], [H], 'o', color='tab:orange')\nax_h.set_title('Max Height vs Launch Angle')\nax_h.set_ylabel('Height (m)')\nax_h.set_xlabel('Launch angle θ (degrees)')\n\nfor ax in [ax_r, ax_t, ax_h]:\n    ax.set_xlim(5, 80)\n\n# Super title tying to cricket analytics context\nfig.suptitle('Application of Mathematics in Cricket Projectile Motion: Predicting range, flight time, and height', y=0.99, fontsize=12)\n\n# Save figure\nout_name = 'cricket_projectile_motion.png'\nplt.savefig(out_name, dpi=200, bbox_inches='tight')\nprint(f'Saved figure to {out_name}')\n",
      "run_instructions": "Run: python3 cricket_projectile_motion.py\nThis will save 'cricket_projectile_motion.png' in the working directory.",
      "python_packages": [
        "matplotlib",
        "numpy"
      ],
      "r_packages": [],
      "latex_requires": []
    }
  },
  {
    "ok": false,
    "topic": "explain me projectile motion using cricket",
    "slide_id": 8,
    "slide_name": "Influence of Air Resistance and Real-World Factors",
    "workdir": "/home/dikshant-kukreja/Desktop/extramarks/viz_outputs/explain_me_projectile_motion_using_cricket/08_Influence_of_Air_Resistance_and_Real-World_Factors",
    "language": "python",
    "filename": "cricket_air_resistance_figure.py",
    "run_exit_code": 1,
    "stdout": "",
    "stderr": "  File \u001b[35m\"/home/dikshant-kukreja/Desktop/extramarks/viz_outputs/explain_me_projectile_motion_using_cricket/08_Influence_of_Air_Resistance_and_Real-World_Factors/cricket_air_resistance_figure.py\"\u001b[0m, line \u001b[35m174\u001b[0m\n    ax.annotate(\u001b[1;31m'\u001b[0mSteeper downward path\n                \u001b[1;31m^\u001b[0m\n\u001b[1;35mSyntaxError\u001b[0m: \u001b[35munterminated string literal (detected at line 174)\u001b[0m\n",
    "saved_artifacts": [],
    "model_json": {
      "language": "python",
      "filename": "cricket_air_resistance_figure.py",
      "code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef simulate_with_drag(v0, angle_deg, m, Cd, A, rho, wind=(0.0, 0.0), g=9.81, dt=0.002, t_max=15.0):\n    \"\"\"\n    Simulate 2D projectile motion with quadratic air drag and constant wind using RK4.\n    Returns time, x, y arrays that end exactly at ground (y=0) by linear interpolation.\n    \"\"\"\n    th = np.deg2rad(angle_deg)\n    vx0 = v0 * np.cos(th)\n    vy0 = v0 * np.sin(th)\n\n    def deriv(state):\n        x, y, vx, vy = state\n        v_rel_x = vx - wind[0]\n        v_rel_y = vy - wind[1]\n        speed_rel = np.hypot(v_rel_x, v_rel_y)\n        # Drag force vector (opposes relative motion)\n        Fx = -0.5 * rho * Cd * A * speed_rel * v_rel_x\n        Fy = -0.5 * rho * Cd * A * speed_rel * v_rel_y\n        ax = Fx / m\n        ay = Fy / m - g\n        return np.array([vx, vy, ax, ay])\n\n    # Initialize\n    t = 0.0\n    state = np.array([0.0, 0.0, vx0, vy0])\n    Ts = [t]\n    Xs = [state[0]]\n    Ys = [state[1]]\n\n    while t < t_max:\n        # RK4 step\n        k1 = deriv(state)\n        k2 = deriv(state + 0.5 * dt * k1)\n        k3 = deriv(state + 0.5 * dt * k2)\n        k4 = deriv(state + dt * k3)\n        state_next = state + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n        t_next = t + dt\n\n        # Record\n        Ts.append(t_next)\n        Xs.append(state_next[0])\n        Ys.append(state_next[1])\n\n        # Check ground crossing\n        if Ys[-2] >= 0.0 and Ys[-1] < 0.0:\n            # Linear interpolation between the last two points to find exact landing\n            y1, y2 = Ys[-2], Ys[-1]\n            x1, x2 = Xs[-2], Xs[-1]\n            t1, t2 = Ts[-2], Ts[-1]\n            frac = y1 / (y1 - y2 + 1e-12)\n            x_land = x1 + frac * (x2 - x1)\n            t_land = t1 + frac * (t2 - t1)\n            # Replace the last point with the interpolated landing point at y=0\n            Ts[-1] = t_land\n            Xs[-1] = x_land\n            Ys[-1] = 0.0\n            break\n\n        # Prepare next step\n        state = state_next\n        t = t_next\n\n    return np.array(Ts), np.array(Xs), np.array(Ys)\n\n\ndef ideal_projectile(v0, angle_deg, g=9.81, num=400):\n    th = np.deg2rad(angle_deg)\n    t_f = 2 * v0 * np.sin(th) / g\n    t = np.linspace(0, t_f, num)\n    x = v0 * np.cos(th) * t\n    y = v0 * np.sin(th) * t - 0.5 * g * t**2\n    return t, x, y, t_f\n\n\ndef main():\n    # Physical parameters for a cricket ball\n    g = 9.81\n    m = 0.156  # kg\n    r = 0.036  # m (approx radius)\n    A = np.pi * r**2  # cross-sectional area\n    rho = 1.225  # kg/m^3 (sea level, dry air)\n    Cd_smooth = 0.45  # representative for smoother/shiny side\n\n    # Launch conditions (typical strong throw/shot)\n    v0 = 35.0  # m/s\n    angle = 35.0  # degrees\n\n    # Compute ideal (no drag)\n    t_id, x_id, y_id, t_id_land = ideal_projectile(v0, angle, g=g)\n    R_id = x_id[-1]\n\n    # Drag cases\n    cases = [\n        {\n            'label': 'Drag (no wind)',\n            'wind': (0.0, 0.0),\n            'Cd': Cd_smooth,\n            'rho': rho,\n            'color': 'tab:blue',\n            'z': 3\n        },\n        {\n            'label': 'Drag + headwind 5 m/s',\n            'wind': (-5.0, 0.0),  # air moving opposite to ball flight\n            'Cd': Cd_smooth,\n            'rho': rho,\n            'color': 'tab:red',\n            'z': 3\n        },\n        {\n            'label': 'Drag + tailwind 5 m/s',\n            'wind': (5.0, 0.0),  # air moving with the ball\n            'Cd': Cd_smooth,\n            'rho': rho,\n            'color': 'tab:green',\n            'z': 3\n        }\n    ]\n\n    sim_results = []\n    for case in cases:\n        t, x, y = simulate_with_drag(v0, angle, m, case['Cd'], A, case['rho'], wind=case['wind'], g=g, dt=0.002, t_max=15.0)\n        sim_results.append({\n            'label': case['label'],\n            'x': x,\n            'y': y,\n            't': t,\n            'color': case['color']\n        })\n\n    # Prepare figure\n    plt.rcParams.update({\n        'figure.dpi': 120,\n        'font.size': 11\n    })\n    fig, ax = plt.subplots(figsize=(9, 6))\n\n    # Plot ideal curve\n    ax.plot(x_id, y_id, linestyle='--', color='gray', linewidth=2.0, label='Ideal (no air resistance)', zorder=2)\n\n    # Plot drag curves and landing markers\n    landing_points = []\n    for res in sim_results:\n        ax.plot(res['x'], res['y'], color=res['color'], linewidth=2.2, label=res['label'], zorder=3)\n        x_land = res['x'][-1]\n        t_land = res['t'][-1]\n        landing_points.append((res['label'], x_land, t_land, res['color']))\n        ax.plot([x_land], [0.0], marker='o', color=res['color'], markersize=6, zorder=4)\n\n    # Ideal landing marker\n    ax.plot([R_id], [0.0], marker='s', color='gray', markersize=6, zorder=3)\n\n    # Ground line\n    xmax_all = max([R_id] + [lp[1] for lp in landing_points])\n    ax.hlines(0, 0, xmax_all * 1.05, colors='k', linestyles='-', linewidth=0.8, alpha=0.4)\n\n    # Annotate shorter range and flight time (ideal vs drag no wind)\n    # find the no-wind case landing\n    x_land_nowind = [lp[1] for lp in landing_points if 'no wind' in lp[0]][0]\n    t_land_nowind = [lp[2] for lp in landing_points if 'no wind' in lp[0]][0]\n\n    ax.annotate('', xy=(x_land_nowind, 0.0), xytext=(R_id, 0.0),\n                arrowprops=dict(arrowstyle='<->', color='black', lw=1.2))\n    mid_x = 0.5 * (x_land_nowind + R_id)\n    ax.text(mid_x, 0.8, 'Range reduced by drag', ha='center', va='bottom')\n\n    # Annotate steeper descent on drag (no wind) curve\n    # pick a point late in flight on the no-wind drag trajectory\n    nowind_curve = [res for res in sim_results if res['label'] == 'Drag (no wind)'][0]\n    idx = int(0.75 * len(nowind_curve['x']))\n    ax.annotate('Steeper downward path\nwith air resistance',\n                xy=(nowind_curve['x'][idx], nowind_curve['y'][idx]),\n                xytext=(nowind_curve['x'][idx] - 35, nowind_curve['y'][idx] + 8),\n                arrowprops=dict(arrowstyle='->', color='tab:blue', lw=1.2),\n                color='tab:blue', ha='left', va='bottom')\n\n    # Add small text notes about real-world factors\n    ax.text(xmax_all * 0.55, 13,\n            'Wind alters relative air speed (headwind reduces range,\\n'\n            'tailwind increases it). Humidity and ball roughness\\n'\n            'change air density and drag coefficient, shifting curves.',\n            bbox=dict(boxstyle='round', facecolor='white', alpha=0.8, ec='gray'))\n\n    # Axes labels and title\n    ax.set_title('Cricket Ball Trajectories: Effect of Air Resistance and Wind')\n    ax.set_xlabel('Horizontal distance (m)')\n    ax.set_ylabel('Height (m)')\n\n    # Limits\n    ax.set_xlim(0, max(130, xmax_all * 1.05))\n    ax.set_ylim(0, 40)\n\n    # Legend with landing info\n    legend_labels = ['Ideal (no air resistance)']\n    for label, xL, tL, color in landing_points:\n        legend_labels.append(f\"{label} — range: {xL:.1f} m, time: {tL:.2f} s\")\n    ax.legend(legend_labels, loc='upper right', framealpha=0.95)\n\n    ax.grid(True, linestyle='--', linewidth=0.6, alpha=0.5)\n\n    # Save figure\n    outfile = 'cricket_projectile_air_resistance.png'\n    plt.tight_layout()\n    plt.savefig(outfile, dpi=200)\n    print(f'Figure saved to {outfile}')\n\n\nif __name__ == '__main__':\n    main()\n",
      "run_instructions": "Run: python cricket_air_resistance_figure.py\nThis will save 'cricket_projectile_air_resistance.png' in the working directory.",
      "python_packages": [
        "numpy",
        "matplotlib"
      ],
      "r_packages": [],
      "latex_requires": []
    }
  },
  {
    "ok": true,
    "topic": "explain me projectile motion using cricket",
    "slide_id": 2,
    "slide_name": "Components of Initial Velocity",
    "workdir": "/home/dikshant-kukreja/Desktop/extramarks/viz_outputs/explain_me_projectile_motion_using_cricket/02_Components_of_Initial_Velocity",
    "language": "python",
    "filename": "cricket_projectile_components.py",
    "run_exit_code": 0,
    "stdout": "Saved figure to cricket_projectile_components.png\n",
    "stderr": "",
    "saved_artifacts": [
      "cricket_projectile_components.png"
    ],
    "model_json": {
      "language": "python",
      "filename": "cricket_projectile_components.py",
      "code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Arc, Rectangle\n\n\ndef trajectory(v0, theta_deg, g=9.81, n=300):\n    theta = np.radians(theta_deg)\n    t_flight = 2 * v0 * np.sin(theta) / g\n    t = np.linspace(0, t_flight, n)\n    x = v0 * np.cos(theta) * t\n    y = v0 * np.sin(theta) * t - 0.5 * g * t**2\n    return x, y\n\n\ndef range_of(v0, theta_deg, g=9.81):\n    theta = np.radians(theta_deg)\n    return (v0**2 * np.sin(2*theta)) / g\n\n\ndef max_height(v0, theta_deg, g=9.81):\n    theta = np.radians(theta_deg)\n    return (v0**2 * (np.sin(theta))**2) / (2*g)\n\n\ndef apex_x(v0, theta_deg, g=9.81):\n    theta = np.radians(theta_deg)\n    return (v0**2 * np.sin(2*theta)) / (2*g)\n\n\nif __name__ == \"__main__\":\n    # Parameters (representative of a cricket shot)\n    v0 = 35.0  # m/s\n    g = 9.81   # m/s^2\n    angles = [25, 45, 65]  # low, balanced, high\n\n    # Compute trajectories\n    data = {}\n    ranges = []\n    for ang in angles:\n        x, y = trajectory(v0, ang, g)\n        data[ang] = (x, y)\n        ranges.append(range_of(v0, ang, g))\n\n    Rmax = max(ranges)\n\n    # Figure setup\n    plt.rcParams.update({\"font.size\": 11})\n    fig, ax = plt.subplots(figsize=(10, 6))\n\n    # Draw a simple grass field under y=0\n    grass_left = -0.06 * Rmax\n    grass_right = 1.06 * Rmax\n    grass_depth = 0.35\n    ax.add_patch(Rectangle((grass_left, -grass_depth), grass_right - grass_left, grass_depth,\n                           facecolor=\"#a7d99b\", edgecolor=\"none\", zorder=0))\n    ax.axhline(0, color=\"forestgreen\", lw=3, zorder=1)\n\n    # Colors for trajectories\n    colors = {25: \"#ff7f0e\", 45: \"#1f77b4\", 65: \"#2ca02c\"}\n    styles = {25: (0, (4, 3)), 45: \"-\", 65: (0, (4, 3))}\n    alphas = {25: 0.9, 45: 1.0, 65: 0.9}\n\n    # Plot trajectories\n    for ang in angles:\n        x, y = data[ang]\n        ax.plot(x, y, color=colors[ang], lw=2.5 if ang == 45 else 2.0,\n                linestyle=styles[ang], alpha=alphas[ang], label=f\"{ang}°\")\n\n    # Primary (featured) angle for component illustration\n    theta_deg = 45\n    theta = np.radians(theta_deg)\n    x45, y45 = data[theta_deg]\n\n    # Mark discrete ball positions along the 45° path (cricket ball)\n    t_flight = 2 * v0 * np.sin(theta) / g\n    t_marks = np.linspace(0, t_flight, 7)\n    x_marks = v0 * np.cos(theta) * t_marks\n    y_marks = v0 * np.sin(theta) * t_marks - 0.5 * g * t_marks**2\n    ax.scatter(x_marks, y_marks, s=28, color=\"#c71f1f\", edgecolor=\"white\", zorder=5, label=\"Ball positions\")\n\n    # Component arrows at origin for 45°\n    L = 0.18 * Rmax  # visualization length scale for velocity vectors\n    vx_ratio = np.cos(theta)\n    vy_ratio = np.sin(theta)\n\n    # Resultant v0 arrow\n    ax.annotate(\"\", xy=(L*vx_ratio, L*vy_ratio), xytext=(0, 0),\n                arrowprops=dict(arrowstyle=\"->\", lw=2.8, color=\"#6a3d9a\"), zorder=6)\n    ax.text(L*vx_ratio*1.05, L*vy_ratio*1.05, \"Initial speed v0\\n(launch angle θ)\", color=\"#6a3d9a\",\n            ha=\"left\", va=\"bottom\")\n\n    # Horizontal component v0x\n    ax.annotate(\"\", xy=(L*vx_ratio, 0), xytext=(0, 0),\n                arrowprops=dict(arrowstyle=\"->\", lw=2.2, color=\"#d45500\"), zorder=6)\n    ax.text(L*vx_ratio*0.5, -0.05*L, \"v0x = v0 cos θ\", color=\"#d45500\", ha=\"center\", va=\"top\")\n\n    # Vertical component v0y\n    ax.annotate(\"\", xy=(0, L*vy_ratio), xytext=(0, 0),\n                arrowprops=dict(arrowstyle=\"->\", lw=2.2, color=\"#2ca02c\"), zorder=6)\n    ax.text(-0.02*Rmax, L*vy_ratio*0.5, \"v0y = v0 sin θ\", color=\"#2ca02c\", ha=\"right\", va=\"center\")\n\n    # Projection guides (dashed)\n    ax.plot([L*vx_ratio, L*vx_ratio], [0, L*vy_ratio], linestyle=(0, (3, 3)), color=\"#666666\", lw=1.2)\n    ax.plot([0, L*vx_ratio], [L*vy_ratio, L*vy_ratio], linestyle=(0, (3, 3)), color=\"#666666\", lw=1.2)\n\n    # Angle arc for θ\n    arc_r = 0.65 * L\n    arc = Arc((0, 0), width=2*arc_r, height=2*arc_r, angle=0, theta1=0, theta2=theta_deg,\n              color=\"#6a3d9a\", lw=2)\n    ax.add_patch(arc)\n    ax.text(arc_r*0.85*np.cos(np.radians(theta_deg/2)), arc_r*0.85*np.sin(np.radians(theta_deg/2)),\n            \"θ\", color=\"#6a3d9a\", ha=\"center\", va=\"center\")\n\n    # Range annotation (for 45°)\n    R = range_of(v0, theta_deg, g)\n    y_range_annot = -0.22 * grass_depth\n    ax.annotate(\"\", xy=(R, y_range_annot), xytext=(0, y_range_annot),\n                arrowprops=dict(arrowstyle=\"<->\", lw=2, color=\"#333333\"))\n    ax.text(R/2, y_range_annot - 0.03, \"Horizontal distance (Range)\\nmainly influenced by v0x\",\n            ha=\"center\", va=\"top\", color=\"#333333\")\n\n    # Max height annotation (for 45°)\n    H = max_height(v0, theta_deg, g)\n    x_ap = apex_x(v0, theta_deg, g)\n    ax.annotate(\"\", xy=(x_ap, H), xytext=(x_ap, 0),\n                arrowprops=dict(arrowstyle=\"<->\", lw=2, color=\"#333333\"))\n    ax.text(x_ap + 0.02*Rmax, H/2, \"Maximum height\\nset by v0y\", ha=\"left\", va=\"center\", color=\"#333333\")\n\n    # Narrative labels near low/high angle paths\n    ax.text(data[25][0].max()*0.75, max(data[25][1])*0.6, \"Lower angle:\\nmore v0x,\\nflatter path\", color=colors[25],\n            ha=\"center\", va=\"center\")\n    ax.text(data[65][0].max()*0.55, max(data[65][1])*0.75, \"Higher angle:\\nmore v0y,\\nhigher but shorter\", color=colors[65],\n            ha=\"center\", va=\"center\")\n\n    # Legend for trajectories\n    ax.legend(title=\"Launch angles\", loc=\"upper right\", frameon=True)\n\n    # Axes formatting\n    ax.set_xlim(grass_left, grass_right)\n    y_top = max(max(y) for _, y in data.values())\n    ax.set_ylim(-grass_depth, y_top * 1.15)\n    ax.set_xlabel(\"Horizontal distance (m)\")\n    ax.set_ylabel(\"Height (m)\")\n    ax.set_title(\"Components of Initial Velocity: Cricket Projectile Motion\")\n    ax.grid(True, linestyle=(0, (3, 3)), alpha=0.4)\n\n    # Tidy and save\n    plt.tight_layout()\n    out_name = \"cricket_projectile_components.png\"\n    plt.savefig(out_name, dpi=200)\n    # Also show if run interactively\n    # plt.show()\n    print(f\"Saved figure to {out_name}\")\n",
      "run_instructions": "Run: python cricket_projectile_components.py\nThis will save 'cricket_projectile_components.png' in the working directory.",
      "python_packages": [
        "matplotlib",
        "numpy"
      ],
      "r_packages": [],
      "latex_requires": []
    }
  }
]